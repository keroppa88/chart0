<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>225チャート爆速くん</title>
  <style>
    body { margin: 0; padding: 1rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: #f5f5f5; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

    .title-row{ display:flex; align-items:baseline; gap:10px; }
    h1 { margin: 0; font-size: 1.5rem; color: #333; }
    .help-btn{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .help-btn:hover{ background:#d5d5d5; }

    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal{ width:min(720px, calc(100vw - 40px)); background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.25); padding:14px 16px; }
    .modal-header{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .modal-title{ font-size:14px; font-weight:700; margin:0; }
    .modal-close{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .modal-close:hover{ background:#d5d5d5; }
    .modal-body{ font-size:13px; color:#333; line-height:1.7; white-space:pre-line; }

    .controls-row { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:15px; align-items:center; padding-bottom:10px; border-bottom:1px solid #eee; }
    .param-group { display:flex; align-items:center; gap:6px; font-size:13px; background:#f9f9f9; padding:4px 8px; border-radius:4px; border:1px solid #eee; }
    .param-group label { font-weight:600; color:#555; }
    .param-group input { width:45px; padding:2px 4px; border:1px solid #ccc; border-radius:3px; text-align:center; }
    .param-group select{ padding:2px 6px; border:1px solid #ccc; border-radius:3px; background:#fff; }

    .hint { font-size:12px; color:#666; }
    .legend { display:flex; gap:15px; font-size:12px; margin-bottom:10px; flex-wrap:wrap; }
    .legend-item { display:flex; align-items:center; gap:4px; }
    .legend-color { width:12px; height:12px; border-radius:2px; }

    canvas { display:block; width:100%; cursor:crosshair; }
    #mainChart { height:350px; border:1px solid #ddd; border-bottom:none; }

    .indicator-container { border:1px solid #ddd; border-top:none; background:#fff; position:relative; }
    .indicator-controls { position:absolute; top:2px; right:2px; pointer-events:auto; display:flex; gap:2px; z-index:10; }
    .btn-icon { width:16px; height:16px; border:none; color:#fff; font-size:10px; line-height:1; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:2px; opacity:0.7; }
    .btn-icon:hover { opacity:1; }
    .btn-move { background:#2196f3; }
    .btn-toggle { background:#666; }
    .indicator-wrapper { height:120px; transition:height 0.2s; overflow:hidden; }
    .indicator-wrapper.collapsed { height:0; }
    .indicator-canvas { height:100%; width:100%; }

    .tooltip { position:absolute; background:rgba(255,255,255,0.95); border:1px solid #999; padding:8px; border-radius:4px; font-size:12px; pointer-events:none; display:none; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:100; line-height:1.4; white-space:nowrap; }
  </style>
</head>
<body>

<div class="container">
  <div class="title-row">
    <h1>株価チャート</h1>
    <button id="helpBtn" class="help-btn" type="button">使い方</button>
  </div>

  <div class="controls-row" style="margin-top:15px;">
    <div class="param-group">
      <label>銘柄</label>
      <select id="symbolSelect">
        <option value="">-</option>
      </select>
    </div>

    <div class="param-group">
      <label>クイック</label>
      <select id="quickSelect" title="表示本数を即変更">
        <option value="">-</option>
        <option value="20">20</option>
        <option value="100" selected>100</option>
        <option value="200">200</option>
        <option value="500">500</option>
      </select>
    </div>

    <span id="autoStatus" class="hint">combined_long.csv を自動読込します</span>
    <span id="status" class="hint" style="margin-left:auto;"></span>
  </div>

  <div class="controls-row">
    <span class="hint" id="viewInfo">表示本数: - / 表示範囲: -</span>
    <span class="hint" style="margin-left:auto;">ホイール: 前=縮める(−1) / 後=広げる(+1) ・ ドラッグ: 左右に移動</span>
  </div>

  <div class="controls-row">
    <div class="param-group"><label>MA1</label><input type="number" id="ma1Period" value="20"></div>
    <div class="param-group"><label>MA2</label><input type="number" id="ma2Period" value="60"></div>
    <div class="param-group"><label>RSI</label><input type="number" id="rsiPeriod" value="14"></div>
    <div class="param-group"><label>Stoch K</label><input type="number" id="stochK" value="14"></div>
    <div class="param-group"><label>Stoch D</label><input type="number" id="stochD" value="3"></div>
    <div class="param-group"><label>MACD S</label><input type="number" id="macdShort" value="12"></div>
    <div class="param-group"><label>MACD L</label><input type="number" id="macdLong" value="26"></div>
    <div class="param-group"><label>Sig</label><input type="number" id="macdSignal" value="9"></div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background:#333"></div><span id="priceLegend">終値（折れ線）</span></div>
    <div class="legend-item"><div class="legend-color" style="background:#ff9800"></div>MA1</div>
    <div class="legend-item"><div class="legend-color" style="background:#2196f3"></div>MA2</div>
    <div class="legend-item"><div class="legend-color" style="background:#9c27b0"></div>RSI</div>
    <div class="legend-item"><div class="legend-color" style="background:#00bcd4"></div>%K</div>
    <div class="legend-item"><div class="legend-color" style="background:#ff5722"></div>%D</div>
  </div>

  <canvas id="mainChart"></canvas>

  <div id="indicatorsList">
    <div class="indicator-container" id="macdContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('macd')">−</button>
      </div>
      <div class="indicator-wrapper" id="macdWrapper">
        <canvas class="indicator-canvas" id="macdChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="stochContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('stoch')">−</button>
      </div>
      <div class="indicator-wrapper" id="stochWrapper">
        <canvas class="indicator-canvas" id="stochChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="rsiContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('rsi')">−</button>
      </div>
      <div class="indicator-wrapper" id="rsiWrapper">
        <canvas class="indicator-canvas" id="rsiChart"></canvas>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>
</div>

<div id="helpModal" class="modal-overlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-header">
      <p class="modal-title" id="helpModalTitle">使い方</p>
      <button id="helpCloseBtn" class="modal-close" type="button">閉じる</button>
    </div>
    <div class="modal-body">
- 最初に日経225銘柄の日足四本値を全て読み込む。平日18時頃に自動更新。
- 銘柄コード欄にマウスを合わせて左右矢印ボタンで銘柄爆速切り替え。
- マウスホイールでチャート拡大縮小など。
- テクニカル指標の位置変更が可能。数字変更で動的に指標描画が変更。
    </div>
  </div>
</div>

<script>
let longRows = [];
let chartListItems = null;
let series = [];
let displayCount = 100;
let offsetX = 0;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;

let params = {
  ma1: 20, ma2: 60,
  rsi: 14,
  stochK: 14, stochD: 3,
  macdShort: 12, macdLong: 26, macdSignal: 9
};

let mainCanvas, mainCtx;
let macdCanvas, macdCtx;
let stochCanvas, stochCtx;
let rsiCanvas, rsiCtx;
let tooltip;

let collapsed = { macd: false, stoch: false, rsi: false };

let indicators = {
  ma1: [], ma2: [],
  rsi: [],
  stoch: { k: [], d: [] },
  macd: { macd: [], signal: [], hist: [] }
};

let backBuffers = { main: null, macd: null, stoch: null, rsi: null };
function resetBackBuffers(){ backBuffers.main = backBuffers.macd = backBuffers.stoch = backBuffers.rsi = null; }
function saveBackBuffers(){
  try{
    backBuffers.main = mainCtx.getImageData(0,0,mainCanvas.width, mainCanvas.height);
    backBuffers.macd = (!collapsed.macd) ? macdCtx.getImageData(0,0,macdCanvas.width, macdCanvas.height) : null;
    backBuffers.stoch = (!collapsed.stoch) ? stochCtx.getImageData(0,0,stochCanvas.width, stochCanvas.height) : null;
    backBuffers.rsi = (!collapsed.rsi) ? rsiCtx.getImageData(0,0,rsiCanvas.width, rsiCanvas.height) : null;
  }catch(e){}
}
function restoreBackBuffers(){
  try{
    if(backBuffers.main) mainCtx.putImageData(backBuffers.main,0,0);
    if(!collapsed.macd && backBuffers.macd) macdCtx.putImageData(backBuffers.macd,0,0);
    if(!collapsed.stoch && backBuffers.stoch) stochCtx.putImageData(backBuffers.stoch,0,0);
    if(!collapsed.rsi && backBuffers.rsi) rsiCtx.putImageData(backBuffers.rsi,0,0);
  }catch(e){}
}

function toNum(s){ if(s==null) return NaN; return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim()); }
function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}
function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}
function parseLongFormat(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) throw new Error("データが空です");
  const delim=detectDelimiter(lines[0]);
  const header=parseDelimitedLine(lines[0],delim).map(s=>s.replace(/\r/g,'').trim());

  const idxDate=header.indexOf("日付");
  const idxName=header.indexOf("商品名");
  const idxVal=header.indexOf("数値");
  if(idxDate<0||idxName<0||idxVal<0) throw new Error("必須列(日付, 商品名, 数値)が見つかりません");

  const rows=[];
  for(let i=1;i<lines.length;i++){
    const cols=parseDelimitedLine(lines[i],delim);
    if(!cols || cols.length===0) continue;
    const date=(cols[idxDate]||"").trim();
    const name=(cols[idxName]||"").trim();
    const value=toNum(cols[idxVal]);
    if(!date || !name || Number.isNaN(value)) continue;
    rows.push({date, name, value});
  }
  return rows;
}

function parseChartList(text){
  const raw = String(text||"").replace(/\uFEFF/g,'').trim();
  if(!raw) return [];
  const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
  if(lines.length===0) return [];

  const delim = detectDelimiter(lines[0]);
  const out=[];
  for(let i=0;i<lines.length;i++){
    const cols = parseDelimitedLine(lines[i], delim).map(s=>s.trim());
    if(!cols || cols.length===0) continue;
    const value = cols[0];
    const label = cols[1] || value;
    out.push({value, label});
  }
  return out;
}

const OHLC_FIELDS = ["始値","高値","安値","終値"];
const OHLC_RE = /(始値|高値|安値|終値)$/;

let chartMode = "line";
let symbolMeta = null;

function splitOhlcName(name){
  const m = String(name||"").match(OHLC_RE);
  if(!m) return { base: String(name||""), field: null };
  return { base: String(name||"").slice(0, -m[1].length), field: m[1] };
}

function buildSymbolMeta(rows){
  const allNames = new Set();
  const baseToFields = new Map();
  for(const r of rows || []){
    if(!r || !r.name) continue;
    allNames.add(r.name);
    const sp = splitOhlcName(r.name);
    if(sp.field){
      if(!baseToFields.has(sp.base)) baseToFields.set(sp.base, new Set());
      baseToFields.get(sp.base).add(sp.field);
    }
  }
  const candleBaseSet = new Set();
  for(const [base, fields] of baseToFields.entries()){
    if(OHLC_FIELDS.every(f => fields.has(f))) candleBaseSet.add(base);
  }
  return { allNames, candleBaseSet, baseToFields };
}

function populateSymbolSelect(){
  const sel = document.getElementById('symbolSelect');
  if(!sel) return;

  const current = sel.value;
  if(!symbolMeta) symbolMeta = buildSymbolMeta(longRows);

  sel.innerHTML = "";

  if(Array.isArray(chartListItems) && chartListItems.length > 0){
    for(const item of chartListItems){
      const opt = document.createElement('option');
      opt.value = item.value;
      // 9984,ソフバン の形式で表示
      opt.textContent = item.value + (item.label !== item.value ? "," + item.label : "");
      sel.appendChild(opt);
    }
  } else {
    const candleBases = Array.from(symbolMeta.candleBaseSet).sort();
    const names = Array.from(symbolMeta.allNames).sort();
    for(const b of candleBases){
      const opt = document.createElement('option');
      opt.value = b; opt.textContent = b;
      sel.appendChild(opt);
    }
    for(const n of names){
      const opt = document.createElement('option');
      opt.value = n; opt.textContent = n;
      sel.appendChild(opt);
    }
  }

  if(current && Array.from(sel.options).some(o=>o.value===current)) sel.value = current;
}

function buildLineSeriesFromLong(rows, targetName){
  const map=new Map();
  for(const r of rows) if(r.name===targetName) map.set(r.date, r.value);
  const dates=Array.from(map.keys()).sort((a,b)=>String(a).localeCompare(String(b)));
  return dates.map(d=>{
    const v=map.get(d);
    return {date:d, open:v, high:v, low:v, close:v};
  });
}

function buildOhlcSeriesFromLong(rows, baseName){
  const names = { open: baseName + "始値", high: baseName + "高値", low: baseName + "安値", close: baseName + "終値" };
  const byDate = new Map();
  for(const r of rows || []){
    if(!r || !r.date) continue;
    if(r.name!==names.open && r.name!==names.high && r.name!==names.low && r.name!==names.close) continue;
    if(!byDate.has(r.date)) byDate.set(r.date, {date:r.date, open:null, high:null, low:null, close:null});
    const o = byDate.get(r.date);
    if(r.name===names.open)  o.open = r.value;
    if(r.name===names.high)  o.high = r.value;
    if(r.name===names.low)   o.low  = r.value;
    if(r.name===names.close) o.close= r.value;
  }
  const dates = Array.from(byDate.keys()).sort((a,b)=>String(a).localeCompare(String(b)));
  return dates.map(d => byDate.get(d));
}

function calculateMA(data, period){
  const result=new Array(data.length).fill(null);
  for(let i=period-1;i<data.length;i++){
    let sum=0; for(let j=0;j<period;j++) sum += data[i-j].close;
    result[i]=sum/period;
  }
  return result;
}

function calculateRSI(data, period){
  const result=new Array(data.length).fill(null);
  if(data.length <= period) return result;
  let gains=0, losses=0;
  for(let i=1;i<=period;i++){
    const diff=data[i].close - data[i-1].close;
    if(diff>0) gains += diff; else losses -= diff;
  }
  let avgGain=gains/period; let avgLoss=losses/period;
  result[period] = (avgLoss===0) ? 100 : (100 - (100/(1+avgGain/avgLoss)));
  for(let i=period+1;i<data.length;i++){
    const diff=data[i].close - data[i-1].close;
    const gain=diff>0?diff:0; const loss=diff<0?-diff:0;
    avgGain=(avgGain*(period-1)+gain)/period; avgLoss=(avgLoss*(period-1)+loss)/period;
    result[i] = (avgLoss===0) ? 100 : (100 - (100/(1+avgGain/avgLoss)));
  }
  return result;
}

function calculateMACD(data, shortP, longP, sigP){
  const macdLine=new Array(data.length).fill(null);
  const signalLine=new Array(data.length).fill(null);
  const histogram=new Array(data.length).fill(null);
  const kS=2/(shortP+1), kL=2/(longP+1);
  let emaS=data[0].close, emaL=data[0].close;
  for(let i=0;i<data.length;i++){
    const price=data[i].close;
    if(i===0){ emaS=price; emaL=price; }
    else{ emaS=(price-emaS)*kS+emaS; emaL=(price-emaL)*kL+emaL; }
    if(i>=longP-1) macdLine[i]=emaS-emaL;
  }
  const firstValid=longP-1; if(firstValid<0 || firstValid>=data.length) return {macd:macdLine, signal:signalLine, hist:histogram};
  let sigEma=macdLine[firstValid]; const kSig=2/(sigP+1);
  for(let i=firstValid;i<data.length;i++){
    if(i===firstValid){ signalLine[i]=macdLine[i]; sigEma=macdLine[i]; }
    else{ sigEma=(macdLine[i]-sigEma)*kSig+sigEma; signalLine[i]=sigEma; }
    histogram[i]=macdLine[i]-signalLine[i];
  }
  return {macd:macdLine, signal:signalLine, hist:histogram};
}

function calculateStochastic(data, kP, dP){
  const kLine=new Array(data.length).fill(null);
  const dLine=new Array(data.length).fill(null);
  for(let i=kP-1;i<data.length;i++){
    let highest=-Infinity, lowest=Infinity;
    for(let j=0;j<kP;j++){ highest=Math.max(highest, data[i-j].high); lowest=Math.min(lowest, data[i-j].low); }
    kLine[i]=(highest!==lowest) ? (((data[i].close-lowest)/(highest-lowest))*100) : 50;
  }
  for(let i=kP-1+dP-1;i<data.length;i++){
    let sum=0; for(let j=0;j<dP;j++) sum += kLine[i-j];
    dLine[i]=sum/dP;
  }
  return {k:kLine, d:dLine};
}

function recomputeIndicators(){
  if(!series || series.length===0) return;
  indicators.ma1 = calculateMA(series, params.ma1);
  indicators.ma2 = calculateMA(series, params.ma2);
  indicators.rsi = calculateRSI(series, params.rsi);
  indicators.stoch = calculateStochastic(series, params.stochK, params.stochD);
  indicators.macd = calculateMACD(series, params.macdShort, params.macdLong, params.macdSignal);
}

function clampView(){
  if(!series || series.length===0){ displayCount=100; offsetX=0; return; }
  displayCount = Math.max(10, Math.min(displayCount, series.length));
  offsetX = Math.max(0, Math.min(offsetX, series.length - displayCount));
}

function getVisibleWindow(){
  clampView();
  const n = series.length;
  const start = Math.max(0, n - displayCount - Math.round(offsetX));
  const end = Math.min(n, start + displayCount);
  const realSlice = series.slice(start, end);
  const padN = displayCount - realSlice.length;
  const pads = new Array(padN).fill(null).map(()=>({date:"", open:null, high:null, low:null, close:null}));
  const visibleCandles = pads.concat(realSlice);
  const visibleIndices = new Array(padN).fill(null).concat(Array.from({length: realSlice.length}, (_,i)=> start + i));
  return { visibleCandles, visibleIndices };
}

function updateViewInfo(){
  const el = document.getElementById('viewInfo');
  if(!series || series.length===0){ el.textContent = `表示本数: ${displayCount} / 表示範囲: -`; return; }
  const { visibleCandles } = getVisibleWindow();
  let sd=null, ed=null;
  for(let c of visibleCandles){ if(c.date){ sd=c.date; break; } }
  for(let i=visibleCandles.length-1;i>=0;i--){ if(visibleCandles[i].date){ ed=visibleCandles[i].date; break; } }
  el.textContent = `表示本数: ${displayCount} / 表示範囲: ${sd&&ed ? `${sd} ~ ${ed}` : '-'}`;
}

async function autoLoadLongFile(){
  const el=document.getElementById('autoStatus');
  try{
    el.textContent="読み込み中...";
    const res=await fetch('./combined_long.csv', {cache:'no-store'});
    if(!res.ok) throw new Error("fetch失敗");
    longRows=parseLongFormat(await res.text());
    symbolMeta = buildSymbolMeta(longRows);

    try {
      const resC = await fetch('./chartlist.csv', {cache:'no-store'});
      if(resC.ok) chartListItems = parseChartList(await resC.text());
    } catch(e){}

    populateSymbolSelect();
    el.textContent=`ロード完了: ${longRows.length}行`;
    applySymbol();
  }catch(e){ el.textContent=`エラー: ${e.message}`; }
}

function applySymbol(){
  const raw = document.getElementById('symbolSelect')?.value;
  if(!raw) return;
  const sp = splitOhlcName(raw);
  if(sp.field && symbolMeta.candleBaseSet.has(sp.base)){
    chartMode = "candle"; series = buildOhlcSeriesFromLong(longRows, sp.base);
  }else if(symbolMeta.candleBaseSet.has(raw)){
    chartMode = "candle"; series = buildOhlcSeriesFromLong(longRows, raw);
  }else{
    chartMode = "line"; series = buildLineSeriesFromLong(longRows, raw);
  }
  offsetX = 0;
  recomputeIndicators();
  updateViewInfo();
  drawChart();
}

function drawChart(){
  if(!mainCanvas || !series || series.length===0) return;
  const { visibleCandles, visibleIndices } = getVisibleWindow();
  drawMain(visibleCandles, visibleIndices);
  drawMacd(visibleIndices);
  drawStoch(visibleIndices);
  drawRsi(visibleIndices);
  saveBackBuffers();
}

function drawMain(visibleCandles, visibleIndices){
  const ctx=mainCtx;
  const w=mainCanvas.width, h=mainCanvas.height;
  const pad={t:20,b:30,l:10,r:60};
  const chartW=w-pad.l-pad.r;
  const chartH=h-pad.t-pad.b;
  ctx.clearRect(0,0,w,h);

  // 背景に銘柄名を表示
  const sel = document.getElementById('symbolSelect');
  const label = sel?.options[sel.selectedIndex]?.textContent || "";
  if(label){
    ctx.save();
    ctx.font = "bold 60px sans-serif";
    ctx.fillStyle = "rgba(0, 0, 0, 0.12)";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(label, pad.l + 10, pad.t + 10);
    ctx.restore();
  }

  let minP=Infinity, maxP=-Infinity;
  visibleIndices.forEach((sIdx, i)=>{
    const c = visibleCandles[i];
    if(c.high!=null) maxP=Math.max(maxP, c.high);
    if(c.low!=null) minP=Math.min(minP, c.low);
    if(sIdx!=null){
      const m1=indicators.ma1[sIdx], m2=indicators.ma2[sIdx];
      if(m1!=null){ minP=Math.min(minP,m1); maxP=Math.max(maxP,m1); }
      if(m2!=null){ minP=Math.min(minP,m2); maxP=Math.max(maxP,m2); }
    }
  });
  if(minP===Infinity) return;
  const range=(maxP-minP)||1; minP-=range*0.05; maxP+=range*0.05;
  const scaleY=chartH/(maxP-minP);
  const getX=(i)=>pad.l+(i+0.5)*(chartW/visibleCandles.length);
  const getY=(val)=>pad.t+chartH-(val-minP)*scaleY;

  ctx.strokeStyle='#eee';
  for(let i=0;i<=5;i++){
    const y=pad.t+(chartH*i/5); ctx.beginPath(); ctx.moveTo(pad.l,y); ctx.lineTo(w-pad.r,y); ctx.stroke();
    ctx.fillStyle='#666'; ctx.fillText((maxP-(maxP-minP)*(i/5)).toFixed(0), w-pad.r+5, y+4);
  }

  mainCanvas.candlePositions = visibleCandles.map((c, i)=>({ x: getX(i), w: chartW/visibleCandles.length, seriesIndex: visibleIndices[i] }));

  if(chartMode==="candle"){
    const bodyW=(chartW/visibleCandles.length)*0.6;
    visibleCandles.forEach((c,i)=>{
      if(c.open==null) return;
      const x=getX(i), yH=getY(c.high), yL=getY(c.low), yO=getY(c.open), yC=getY(c.close);
      const col = c.close >= c.open ? '#26a69a' : '#ef5350';
      ctx.strokeStyle=col; ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke();
      ctx.fillStyle=col; ctx.fillRect(x - bodyW/2, Math.min(yO, yC), bodyW, Math.max(1, Math.abs(yO-yC)));
    });
  } else {
    ctx.strokeStyle='#333'; ctx.beginPath();
    let moved=false;
    visibleCandles.forEach((c,i)=>{
      if(c.close==null){ moved=false; return; }
      const x=getX(i), y=getY(c.close);
      if(!moved){ ctx.moveTo(x,y); moved=true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  const drawL = (arr, col) => {
    ctx.strokeStyle=col; ctx.beginPath(); let m=false;
    visibleIndices.forEach((sIdx, i)=>{
      if(sIdx==null || arr[sIdx]==null){ m=false; return; }
      const x=getX(i), y=getY(arr[sIdx]);
      if(!m){ ctx.moveTo(x,y); m=true; } else ctx.lineTo(x,y);
    });
    ctx.stroke();
  };
  drawL(indicators.ma1, '#ff9800'); drawL(indicators.ma2, '#2196f3');
}

function drawMacd(visibleIndices){
  if(collapsed.macd) return;
  const ctx=macdCtx; const w=macdCanvas.width, h=macdCanvas.height;
  const pad={t:10,b:10,l:10,r:60}; ctx.clearRect(0,0,w,h);
  const data=indicators.macd; let minV=-1, maxV=1;
  visibleIndices.forEach(sIdx=>{
    if(sIdx==null) return;
    [data.macd[sIdx], data.signal[sIdx], data.hist[sIdx]].forEach(v=>{ if(v!=null){ minV=Math.min(minV,v); maxV=Math.max(maxV,v); }});
  });
  const scaleY=(h-20)/(maxV-minV);
  const getX=(i)=>pad.l+(i+0.5)*((w-pad.l-pad.r)/visibleIndices.length);
  const getY=(v)=>10+(h-20)-(v-minV)*scaleY;
  const y0=getY(0); ctx.strokeStyle='#ccc'; ctx.beginPath(); ctx.moveTo(pad.l,y0); ctx.lineTo(w-pad.r,y0); ctx.stroke();
  visibleIndices.forEach((sIdx,i)=>{
    if(sIdx==null || data.hist[sIdx]==null) return;
    ctx.fillStyle=data.hist[sIdx]>=0?'#26a69a':'#ef5350';
    const x=getX(i), y=getY(data.hist[sIdx]);
    ctx.fillRect(x-2, Math.min(y,y0), 4, Math.abs(y-y0));
  });
}

function drawStoch(visibleIndices){
  if(collapsed.stoch) return;
  const ctx=stochCtx; const w=stochCanvas.width, h=stochCanvas.height;
  const pad={t:10,b:10,l:10,r:60}; ctx.clearRect(0,0,w,h);
  const getX=(i)=>pad.l+(i+0.5)*((w-pad.l-pad.r)/visibleIndices.length);
  const getY=(v)=>10+(h-20)-(v/100)*(h-20);
  ctx.strokeStyle='#eee'; [20,80].forEach(l=>{ ctx.beginPath(); ctx.moveTo(pad.l,getY(l)); ctx.lineTo(w-pad.r,getY(l)); ctx.stroke(); });
  const drawL=(arr,col)=>{
    ctx.strokeStyle=col; ctx.beginPath(); let m=false;
    visibleIndices.forEach((sIdx,i)=>{
      if(sIdx==null || arr[sIdx]==null){ m=false; return; }
      if(!m){ ctx.moveTo(getX(i),getY(arr[sIdx])); m=true; } else ctx.lineTo(getX(i),getY(arr[sIdx]));
    }); ctx.stroke();
  };
  drawL(indicators.stoch.k, '#00bcd4'); drawL(indicators.stoch.d, '#ff5722');
}

function drawRsi(visibleIndices){
  if(collapsed.rsi) return;
  const ctx=rsiCtx; const w=rsiCanvas.width, h=rsiCanvas.height;
  const pad={t:10,b:10,l:10,r:60}; ctx.clearRect(0,0,w,h);
  const getX=(i)=>pad.l+(i+0.5)*((w-pad.l-pad.r)/visibleIndices.length);
  const getY=(v)=>10+(h-20)-(v/100)*(h-20);
  ctx.strokeStyle='#eee'; [30,70].forEach(l=>{ ctx.beginPath(); ctx.moveTo(pad.l,getY(l)); ctx.lineTo(w-pad.r,getY(l)); ctx.stroke(); });
  ctx.strokeStyle='#9c27b0'; ctx.beginPath(); let m=false;
  visibleIndices.forEach((sIdx,i)=>{
    if(sIdx==null || indicators.rsi[sIdx]==null){ m=false; return; }
    if(!m){ ctx.moveTo(getX(i),getY(indicators.rsi[sIdx])); m=true; } else ctx.lineTo(getX(i),getY(indicators.rsi[sIdx]));
  }); ctx.stroke();
}

function drawCrosshair(x){
  restoreBackBuffers(); if(x<0) return;
  [mainCtx, macdCtx, stochCtx, rsiCtx].forEach((ctx, i)=>{
    if(!ctx || (i>0 && Object.values(collapsed)[i-1])) return;
    ctx.save(); ctx.strokeStyle='#999'; ctx.setLineDash([3,3]);
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ctx.canvas.height); ctx.stroke(); ctx.restore();
  });
}

function handleTooltip(e, canvas){
  if(!mainCanvas.candlePositions || series.length===0) return;
  const mouseX=e.clientX-canvas.getBoundingClientRect().left;
  const p = mainCanvas.candlePositions.find(pp => Math.abs(mouseX - pp.x) < pp.w/2);
  if(!p || p.seriesIndex==null){ tooltip.style.display='none'; drawCrosshair(-1); return; }
  const c = series[p.seriesIndex];
  tooltip.innerHTML=`<strong>${c.date}</strong><br>終値:${c.close.toLocaleString()}`;
  tooltip.style.display='block'; tooltip.style.left=(e.clientX+15)+'px'; tooltip.style.top=(e.clientY+15)+'px';
  drawCrosshair(p.x);
}

function setupEventListeners(){
  document.getElementById('helpBtn').onclick = ()=> document.getElementById('helpModal').style.display='flex';
  document.getElementById('helpCloseBtn').onclick = ()=> document.getElementById('helpModal').style.display='none';
  document.getElementById('symbolSelect').onchange = applySymbol;
  document.getElementById('quickSelect').onchange = (e)=>{ if(e.target.value){ displayCount=parseInt(e.target.value); offsetX=0; applySymbol(); }};
  
  [mainCanvas, macdCanvas, stochCanvas, rsiCanvas].forEach(cvs=>{
    cvs.onwheel = (e)=>{ e.preventDefault(); displayCount += (e.deltaY < 0 ? -1 : 1); applySymbol(); };
    cvs.onmousedown = (e)=>{ isDragging=true; dragStartX=e.clientX; dragStartOffset=offsetX; };
    cvs.onmousemove = (e)=>{ if(isDragging){ offsetX = dragStartOffset + (dragStartX - e.clientX)/(cvs.width/displayCount); applySymbol(); } else handleTooltip(e, cvs); };
    cvs.onmouseup = cvs.onmouseleave = ()=>{ isDragging=false; tooltip.style.display='none'; drawCrosshair(-1); };
  });
}

function init(){
  mainCanvas=document.getElementById('mainChart'); mainCtx=mainCanvas.getContext('2d');
  macdCanvas=document.getElementById('macdChart'); macdCtx=macdCanvas.getContext('2d');
  stochCanvas=document.getElementById('stochChart'); stochCtx=stochCanvas.getContext('2d');
  rsiCanvas=document.getElementById('rsiChart'); rsiCtx=rsiCanvas.getContext('2d');
  tooltip=document.getElementById('tooltip');
  setupEventListeners();
  const res = ()=>{ [mainCanvas, macdCanvas, stochCanvas, rsiCanvas].forEach(c=>{ c.width=c.clientWidth; c.height=c.clientHeight; }); drawChart(); };
  window.onresize = res; res();
  autoLoadLongFile();
}
window.onload = init;
</script>
</body>
</html>


