<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>爆速チャートくん</title>
  <style>
    body { margin: 0; padding: 1rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: #f5f5f5; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

    .title-row{ display:flex; align-items:baseline; gap:10px; }
    h1 { margin: 0; font-size: 1.5rem; color: #333; }
    .help-btn{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .help-btn:hover{ background:#d5d5d5; }
    .arrow-btn{ font-size:12px; padding:3px 8px; background::#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .arrow-btn:hover{ background:#d5d5d5; }
    .arrow-btn:active{ background:#c0c0c0; }

    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal{ width:min(720px, calc(100vw - 40px)); background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.25); padding:14px 16px; }
    .modal-header{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .modal-title{ font-size:14px; font-weight:700; margin:0; }
    .modal-close{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .modal-close:hover{ background:#d5d5d5; }
    .modal-body{ font-size:13px; color:#333; line-height:1.7; white-space:pre-line; }

    .controls-row { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:15px; align-items:center; padding-bottom:10px; border-bottom:1px solid #eee; }
    .param-group { display:flex; align-items:center; gap:3px; font-size:12px; background:#f9f9f9; padding:2px 6px; border-radius:4px; border:1px solid #eee; }
    .param-group label { font-weight:600; color:#555; }
    .param-group input[type="number"] { width:38px; padding:1px 2px; border:1px solid #ccc; border-radius:3px; text-align:center; font-size:12px; }
    .param-group input[type="checkbox"] { margin:0; }
    .param-group select{ padding:2px 6px; border:1px solid #ccc; border-radius:3px; background:#fff; }

    .hint { font-size:12px; color:#666; }
    .view-info { font-size:13.2px; color:#444; font-weight:500; }
    .legend { display:flex; gap:15px; font-size:12px; margin-bottom:10px; flex-wrap:wrap; align-items:center; }
    .legend-group { display:flex; gap:15px; align-items:center; flex-wrap:wrap; }
    .legend-item { display:flex; align-items:center; gap:4px; }
    .label-tight { display:inline-flex; align-items:center; gap:0; }
    .label-tight input { margin:0; }

    canvas { display:block; width:100%; cursor:crosshair; box-sizing:border-box; }
    #mainChart { height:350px; border:1px solid #ddd; border-bottom:none; position:relative; box-sizing:border-box; }

    #indicatorsList { width:100%; }
    .indicator-container { border:1px solid #ddd; border-top:none; background:#fff; position:relative; min-height:24px; width:100%; box-sizing:border-box; }
    .indicator-controls { position:absolute; top:2px; right:2px; pointer-events:auto; display:flex; gap:2px; z-index:10; }
    .btn-icon { width:16px; height:16px; border:none; color:#fff; font-size:10px; line-height:1; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:2px; opacity:0.7; }
    .btn-icon:hover { opacity:1; }
    .btn-move { background:#2196f3; }
    .btn-toggle { background:#666; }
    .btn-expand { background:#4caf50; }
    .indicator-wrapper { height:120px; transition:height 0.2s; overflow:hidden; width:100%; }
    .indicator-wrapper.collapsed { height:0; }
    .params-wrapper { display:flex; flex-wrap:wrap; gap:8px; transition:all 0.2s; overflow:hidden; }
    .params-wrapper.collapsed { height:0; opacity:0; }
    .legend-wrapper { display:flex; gap:15px; flex-wrap:wrap; transition:all 0.2s; overflow:hidden; }
    .legend-wrapper.collapsed { height:0; opacity:0; }
    .indicator-canvas { height:100%; width:100%; }

    .tooltip { position:absolute; background:rgba(255,255,255,0.95); border:1px solid #999; padding:8px; border-radius:4px; font-size:12px; pointer-events:none; display:none; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:100; line-height:1.4; white-space:nowrap; }
  </style>
</head>
<body>

<div class="container">
  <div class="title-row">
    <h1>爆速チャートくん</h1>
    <button id="helpBtn" class="help-btn" type="button">説明</button>
    <button id="prevStockBtn" class="arrow-btn" type="button" title="前の銘柄（←）">◀</button>
    <button id="nextStockBtn" class="arrow-btn" type="button" title="次の銘柄（→）">▶</button>
  </div>

  <div class="controls-row" style="margin-top:15px;">
    <div class="param-group">
      <select id="modeSelect">
        <option value="all">全銘柄</option>
        <option value="225">225銘柄</option>
        <option value="500">500銘柄</option>
      </select>
    </div>

    <div class="param-group">
      <select id="symbolSelect">
        <option value="">読み込み中...</option>
      </select>
    </div>

    <div class="param-group">
      <label>期間変更</label>
      <select id="quickSelect" title="表示本数を即変更">
        <option value="">-</option>
        <option value="20">20</option>
        <option value="100" selected>100</option>
        <option value="200">200</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
      </select>
    </div>

    <span id="autoStatus" class="hint">225chartlist.csv を読込中...</span>
    <span id="viewInfo" class="view-info" style="margin-left:auto;">表示本数: - / 表示範囲: -</span>
  </div>

  <div class="controls-row" style="position:relative; padding-right:25px;">
    <div class="indicator-controls" style="position:absolute; top:2px; right:2px;">
      <button class="btn-icon btn-toggle" onclick="toggleParams()" id="paramsCollapseBtn">−</button>
      <button class="btn-icon btn-expand" onclick="toggleParams()" id="paramsExpandBtn" style="display:none;">+</button>
    </div>
    <div id="paramsWrapper" class="params-wrapper">
      <div class="param-group"><label>MA1</label><input type="number" id="ma1Period" value="20"></div>
      <div class="param-group"><label>MA2</label><input type="number" id="ma2Period" value="60"></div>
      <div class="param-group"><label>VWAP</label><input type="number" id="vwapPeriod" value="5"></div>
      <div class="param-group"><label>RSI</label><input type="number" id="rsiPeriod" value="14"></div>
      <div class="param-group"><label>Stoch K</label><input type="number" id="stochK" value="14"></div>
      <div class="param-group"><label>Stoch D</label><input type="number" id="stochD" value="3"></div>
      <div class="param-group"><label>MACD S</label><input type="number" id="macdShort" value="12"></div>
      <div class="param-group"><label>MACD L</label><input type="number" id="macdLong" value="26"></div>
      <div class="param-group"><label>Sig</label><input type="number" id="macdSignal" value="9"></div>
      <div class="param-group"><label>ATR%</label><input type="number" id="atrPeriod" value="20"></div>
      <div class="param-group"><label>ADX</label><input type="number" id="adxPeriod" value="14"></div>
      <div class="param-group">
        <label style="display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="dochianCheck">
          <span>Donchian</span>
        </label>
        <input type="number" id="dochianPeriod" value="20">
      </div>
      <div class="param-group">
        <label style="display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="keltnerCheck">
          <span>Keltner</span>
        </label>
        <input type="number" id="keltnerPeriod" value="20">
      </div>
    </div>
  </div>



<div class="legend" style="justify-content:flex-end; position:relative; padding-right:25px;">
  <div class="indicator-controls" style="position:absolute; top:2px; right:2px;">
    <button class="btn-icon btn-toggle" onclick="toggleLegend()" id="legendCollapseBtn">−</button>
    <button class="btn-icon btn-expand" onclick="toggleLegend()" id="legendExpandBtn" style="display:none;">+</button>
  </div>
  <div id="legendWrapper" class="legend-wrapper">
    <!-- グループ2: 比較、価格帯別出来高、VWAP、日付ライン -->
    <div class="legend-group">
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="financialInfoCheck" checked>
        <span>情報</span>
      </label>
      
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="compareCheck">
        <span>比較</span>
      </label>

      <select id="compareSymbolSelect" style="padding:2px 6px; border:1px solid #ccc; border-radius:3px; background:#fff; min-width:150px;">
        <option value="">選択してください</option>
      </select>
      
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="volumeProfileCheck">
        <span>価格帯別出来高</span>
      </label>

      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="dateLineCheck">
        <span>日付ライン</span>
      </label>
    </div>
    
    <!-- グループ3: 日足、週足、月足、右スペース -->
    <div class="legend-group">
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="dailyCheck" checked>
        <span>日足</span>
      </label>
      
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="weeklyCheck">
        <span>週足</span>
      </label>
      
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="monthlyCheck">
        <span>月足</span>
      </label>
      
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="rightSpaceCheck">
        <span>右スペース</span>
      </label>
    </div>
  </div>
</div>

  <canvas id="mainChart"></canvas>

  <div id="indicatorsList">
    <div class="indicator-container" id="volumeContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('volume','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('volume','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('volume')" id="volumeCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('volume')" id="volumeExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="volumeWrapper">
        <canvas class="indicator-canvas" id="volumeChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="macdContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('macd')" id="macdCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('macd')" id="macdExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="macdWrapper">
        <canvas class="indicator-canvas" id="macdChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="stochContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('stoch')" id="stochCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('stoch')" id="stochExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="stochWrapper">
        <canvas class="indicator-canvas" id="stochChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="rsiContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('rsi')" id="rsiCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('rsi')" id="rsiExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="rsiWrapper">
        <canvas class="indicator-canvas" id="rsiChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="atrContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('atr','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('atr','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('atr')" id="atrCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('atr')" id="atrExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="atrWrapper">
        <canvas class="indicator-canvas" id="atrChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="adxContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('adx','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('adx','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('adx')" id="adxCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('adx')" id="adxExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="adxWrapper">
        <canvas class="indicator-canvas" id="adxChart"></canvas>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>
</div>

<div id="helpModal" class="modal-overlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-header">
      <p class="modal-title" id="helpModalTitle">使い方</p>
      <button id="helpCloseBtn" class="modal-close" type="button">閉じる</button>
    </div>
    <div class="modal-body">
ハイスピード設計！  
●爆速表示
　　爆速表示!＝左右矢印。左右＝1ずつ、上下＝10ずつ。基本的にはPC使用が前提。
　　スマホ用に左右矢印ボタンを配置。押しっぱなしで高速表示。チャート上部の不要な行は折り畳み可能。
●ローソク足エリア
　　マウスホイールで期間増減、ドラッグで左右移動。
　　日足・週足・月足の切り替え。
　　移動平均線、VWAP線、ドンチャン・チャンネル、ケルトナー・チャンネル、価格帯別出来高など。
　　情報としてチャート表示期間の勝率、陽線率、騰落率、比較時の相関係数などを表示。
　　JPX配信の財務データから時価総額、通期予想PERなども表示。
　　任意の銘柄を比較対象にすることができる。表示範囲初日始値＝100。
●各種テクニカル指標
　　ローソク足エリアの下部にあるテクニカル指標エリアは表示・非表示・場所入れ替えが可能。
　　各種数値入力欄にマウスを合わせた状態であれば、上下ボタンで数値増減、動的描写。
●銘柄
　　全銘柄リストは全市場の約1000銘柄。日経平均銘柄＝225、日経500銘柄＝500。
　　株価指数、業種別指数、商品価格などはETFで代替。半導体株指数は推計値を追加補充。
　　商品ETF、海外株式ETFは「為替ヘッジ無し」。円ベースの値動き。
●仕様
　　平日17時台に当日終値を自動更新。
　　公式JPXAPI→githubに個別CSV設置→HTMLブラウザアプリで表示。
　　chatGPT、Claudeの問答をプログラムに手でコピペする原始人スタイルで開発。
　　2026/01/19～
●開発趣旨
　　巷に普及するチャート閲覧環境は重くて遅い。20年以上、ほとんど進化がみられない分野。
　　yahooファイナンス、ログイン煩雑な証券会社アプリ、プロ用情報端末を超える爆速実現が開発趣旨。
　　JPX（日本取引所）が2026/01/19より個人投資家向けの情報販売を拡充、それに乗っかって開発を開始した。
    </div>
  </div>
</div>

<script>
/* =========================
   State
========================= */
let chartListItems = null;
let allChartListItems = null;
let chart500ListItems = null;
let symbolCache = new Map();
let dailySeries = [];
let series = [];
let timeframe = 'daily';
let displayCount = 100;
let offsetX = 0;

let compareEnabled = false;
let compareDailySeries = [];
let compareSeries = [];
let compareSymbolCode = "";
let compareSymbolName = "";

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;

let params = {
  ma1: 20, ma2: 60,
  vwap: 5,  // 追加
  rsi: 14,
  stochK: 14, stochD: 3,
  macdShort: 12, macdLong: 26, macdSignal: 9,
  atr: 20,
  adx: 14,
  dochian: 20,
  dochianEnabled: false,
  keltner: 20,
  keltnerEnabled: false
};

let mainCanvas, mainCtx;
let volumeCanvas, volumeCtx;
let macdCanvas, macdCtx;
let stochCanvas, stochCtx;
let rsiCanvas, rsiCtx;
let atrCanvas, atrCtx;
let adxCanvas, adxCtx;
let tooltip;

let collapsed = { volume: false, macd: false, stoch: false, rsi: false, atr: false, adx: false };

let indicators = {
  ma1: [], ma2: [],
  rsi: [],
  stoch: { k: [], d: [] },
  macd: { macd: [], signal: [], hist: [] },
  atr: [],
  adx: { adx: [], plusDI: [], minusDI: [] },
  vwap: [], // 追加
  dochian: { high: [], low: [], mid: [] },
  keltner: { upper: [], middle: [], lower: [] }
};

let backBuffers = { main: null, volume: null, macd: null, stoch: null, rsi: null, atr: null, adx: null };
function resetBackBuffers(){ backBuffers.main = backBuffers.volume = backBuffers.macd = backBuffers.stoch = backBuffers.rsi = backBuffers.atr = backBuffers.adx = null; }
function saveBackBuffers(){
  try{
    backBuffers.main = mainCtx.getImageData(0,0,mainCanvas.width, mainCanvas.height);
    backBuffers.volume = (!collapsed.volume) ? volumeCtx.getImageData(0,0,volumeCanvas.width, volumeCanvas.height) : null;
    backBuffers.macd = (!collapsed.macd) ? macdCtx.getImageData(0,0,macdCanvas.width, macdCanvas.height) : null;
    backBuffers.stoch = (!collapsed.stoch) ? stochCtx.getImageData(0,0,stochCanvas.width, stochCanvas.height) : null;
    backBuffers.rsi = (!collapsed.rsi) ? rsiCtx.getImageData(0,0,rsiCanvas.width, rsiCanvas.height) : null;
    backBuffers.atr = (!collapsed.atr) ? atrCtx.getImageData(0,0,atrCanvas.width, atrCanvas.height) : null;
    backBuffers.adx = (!collapsed.adx) ? adxCtx.getImageData(0,0,adxCanvas.width, adxCanvas.height) : null;
  }catch(e){}
}
function restoreBackBuffers(){
  try{
    if(backBuffers.main) mainCtx.putImageData(backBuffers.main,0,0);
    if(!collapsed.volume && backBuffers.volume) volumeCtx.putImageData(backBuffers.volume,0,0);
    if(!collapsed.macd && backBuffers.macd) macdCtx.putImageData(backBuffers.macd,0,0);
    if(!collapsed.stoch && backBuffers.stoch) stochCtx.putImageData(backBuffers.stoch,0,0);
    if(!collapsed.rsi && backBuffers.rsi) rsiCtx.putImageData(backBuffers.rsi,0,0);
    if(!collapsed.atr && backBuffers.atr) atrCtx.putImageData(backBuffers.atr,0,0);
    if(!collapsed.adx && backBuffers.adx) adxCtx.putImageData(backBuffers.adx,0,0);
  }catch(e){}
}

//チェックの初期設定

let currentSymbolDisplay = "";
let rightSpaceEnabled = false;
let dateLineEnabled = false;
let volumeProfileEnabled = false; // 追加（将来用）
let showFinancialInfo = true; // 追加
  
/* =========================
   Data Version
========================= */
function yyyymmddJST(){
  const now = new Date();
  const jst = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
  const y = jst.getFullYear();
  const m = String(jst.getMonth()+1).padStart(2,'0');
  const d = String(jst.getDate()).padStart(2,'0');
  return `${y}${m}${d}`;
}
const DATA_VER = yyyymmddJST();

/* =========================
   Parsing
========================= */
function toNum(s){ 
  if(s==null) return NaN; 
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim()); 
}

function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}

function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}

function parseOHLCVFormat(text){
  const lines = text.trim().split(/\r?\n/);
  if(lines.length < 2) return [];
  
  const delim = detectDelimiter(lines[0]);
  const header = parseDelimitedLine(lines[0], delim).map(s=>s.replace(/\r/g,'').trim());
  
  const idxDate = header.findIndex(h => /date/i.test(h));
  const idxOpen = header.findIndex(h => /open/i.test(h));
  const idxHigh = header.findIndex(h => /high/i.test(h));
  const idxLow = header.findIndex(h => /low/i.test(h));
  const idxClose = header.findIndex(h => /close/i.test(h));
  const idxVolume = header.findIndex(h => /volume/i.test(h));
  const idxTradingValue = header.findIndex(h => /tradingvalue/i.test(h)); // 追加
  const idxUpLimit = header.findIndex(h => /uplimit/i.test(h)); // 追加
  const idxUnderLimit = header.findIndex(h => /underlimit/i.test(h)); // 追加
  
  if(idxDate < 0 || idxClose < 0) return [];
  
  const rows = [];
  for(let i = 1; i < lines.length; i++){
    const cols = parseDelimitedLine(lines[i], delim);
    if(!cols || cols.length === 0) continue;
    
    const date = (cols[idxDate] || "").trim();
    const open = idxOpen >= 0 ? toNum(cols[idxOpen]) : null;
    const high = idxHigh >= 0 ? toNum(cols[idxHigh]) : null;
    const low = idxLow >= 0 ? toNum(cols[idxLow]) : null;
    const close = toNum(cols[idxClose]);
    const volume = idxVolume >= 0 ? toNum(cols[idxVolume]) : null;
    const tradingValue = idxTradingValue >= 0 ? toNum(cols[idxTradingValue]) : null; // 追加
    const upLimit = idxUpLimit >= 0 ? toNum(cols[idxUpLimit]) : 0; // 追加
    const underLimit = idxUnderLimit >= 0 ? toNum(cols[idxUnderLimit]) : 0; // 追加
    
    if(!date || Number.isNaN(close)) continue;
    
    rows.push({
      date,
      open: Number.isNaN(open) ? close : open,
      high: Number.isNaN(high) ? close : high,
      low: Number.isNaN(low) ? close : low,
      close,
      volume: Number.isNaN(volume) ? null : volume,
      tradingValue: Number.isNaN(tradingValue) ? null : tradingValue, // 追加
      upLimit, // 追加
      underLimit // 追加
    });
  }
  
  return rows;
}


function parseChartList(text){
  const raw = String(text||"").replace(/\uFEFF/g,'').trim();
  if(!raw) return [];
  
  const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
  if(lines.length === 0) return [];

  const out = [];
  for(const line of lines){
    const parts = line.split(',').map(s=>s.trim());
    if(parts.length < 2) continue;
    
    const code = parts[0];
    const name = parts[1];
    if(!code) continue;
    
    out.push({ code, name });
  }
  return out;
}

function convertToWeekly(dailyData){
  if(!dailyData || dailyData.length === 0) return [];
  
  const weekly = [];
  let currentWeek = null;
  
  for(const day of dailyData){
    const dateObj = new Date(day.date);
    const dayOfWeek = dateObj.getDay();
    
    if(!currentWeek || dayOfWeek === 1 || dayOfWeek < currentWeek.lastDayOfWeek){
      if(currentWeek){
        weekly.push(currentWeek.data);
      }
      currentWeek = {
        data: {
          date: day.date,
          open: day.open,
          high: day.high,
          low: day.low,
          close: day.close,
          volume: day.volume || 0,
          tradingValue: day.tradingValue || 0, // 追加
          upLimit: day.upLimit || 0, // 追加
          underLimit: day.underLimit || 0 // 追加
        },
        lastDayOfWeek: dayOfWeek
      };
    }else{
      currentWeek.data.high = Math.max(currentWeek.data.high, day.high);
      currentWeek.data.low = Math.min(currentWeek.data.low, day.low);
      currentWeek.data.close = day.close;
      currentWeek.data.volume += (day.volume || 0);
      currentWeek.data.tradingValue += (day.tradingValue || 0); // 追加
      currentWeek.data.upLimit = Math.max(currentWeek.data.upLimit, day.upLimit || 0); // 追加
      currentWeek.data.underLimit = Math.max(currentWeek.data.underLimit, day.underLimit || 0); // 追加
      currentWeek.lastDayOfWeek = dayOfWeek;
    }
  }
  
  if(currentWeek){
    weekly.push(currentWeek.data);
  }
  
  return weekly;
}

function convertToMonthly(dailyData){
  if(!dailyData || dailyData.length === 0) return [];
  
  const monthly = [];
  let currentMonth = null;
  
  for(const day of dailyData){
    const dateObj = new Date(day.date);
    const yearMonth = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
    
    if(!currentMonth || currentMonth.yearMonth !== yearMonth){
      if(currentMonth){
        monthly.push(currentMonth.data);
      }
      currentMonth = {
        yearMonth: yearMonth,
        data: {
          date: day.date,
          open: day.open,
          high: day.high,
          low: day.low,
          close: day.close,
          volume: day.volume || 0,
          tradingValue: day.tradingValue || 0, // 追加
          upLimit: day.upLimit || 0, // 追加
          underLimit: day.underLimit || 0 // 追加
        }
      };
    }else{
      currentMonth.data.high = Math.max(currentMonth.data.high, day.high);
      currentMonth.data.low = Math.min(currentMonth.data.low, day.low);
      currentMonth.data.close = day.close;
      currentMonth.data.volume += (day.volume || 0);
      currentMonth.data.tradingValue += (day.tradingValue || 0); // 追加
      currentMonth.data.upLimit = Math.max(currentMonth.data.upLimit, day.upLimit || 0); // 追加
      currentMonth.data.underLimit = Math.max(currentMonth.data.underLimit, day.underLimit || 0); // 追加
    }
  }
  
  if(currentMonth){
    monthly.push(currentMonth.data);
  }
  
  return monthly;
}

async function loadSymbolCSV(code){
  if(symbolCache.has(code)) return symbolCache.get(code);
  
  try{
    const res = await fetch(`./data/${code}.csv?v=${DATA_VER}`);
    if(!res.ok) throw new Error(`fetch失敗: ${res.status}`);
    
    const text = await res.text();
    const rows = parseOHLCVFormat(text);
    
    symbolCache.set(code, rows);
    return rows;
  }catch(e){
    console.error(`${code}.csv の読み込みエラー:`, e);
    return [];
  }
}

function preloadAdjacentSymbols(currentIndex, listItems){
  if(!listItems || listItems.length === 0) return;
  
  const codes = [
    listItems[currentIndex - 1]?.code,
    listItems[currentIndex + 1]?.code
  ].filter(c => c && !symbolCache.has(c));
  
  codes.forEach(code => {
    loadSymbolCSV(code).catch(() => {});
  });
}

function populateSymbolSelect(){
  const modeSelect = document.getElementById('modeSelect');
  const symbolSelect = document.getElementById('symbolSelect');
  const compareSel = document.getElementById('compareSymbolSelect');
  if(!symbolSelect) return;
  
  const mode = modeSelect?.value || 'all';
  const currentSymbol = symbolSelect.value;
  const currentCompare = compareSel?.value || "";
  
  // モードに応じた銘柄リストを選択
  let listItems;
  if (mode === '225') {
    listItems = chartListItems;
  } else if (mode === '500') {
    listItems = chart500ListItems;
  } else {
    listItems = allChartListItems;
  }
  
  // 銘柄プルダウンを更新
  symbolSelect.innerHTML = "";
  
  if(!Array.isArray(listItems) || listItems.length === 0){
    const opt = document.createElement('option');
    opt.value = "";
    opt.textContent = "銘柄リストが空です";
    symbolSelect.appendChild(opt);
  } else {
    const defaultOpt = document.createElement('option');
    defaultOpt.value = "";
    defaultOpt.textContent = "選択してください";
    symbolSelect.appendChild(defaultOpt);
    
    for(const item of listItems){
      const opt = document.createElement('option');
      opt.value = item.code;
      opt.textContent = `${item.code} ${item.name}`;
      symbolSelect.appendChild(opt);
    }
    
    // 以前選択していた銘柄が新しいリストにも存在すれば再選択
    if(currentSymbol && listItems.some(item => item.code === currentSymbol)){
      symbolSelect.value = currentSymbol;
    }
  }
  
  // 比較用プルダウン（全銘柄を使用）
  if(compareSel) {
    compareSel.innerHTML = '<option value="">選択してください</option>';
    
    if(Array.isArray(allChartListItems) && allChartListItems.length > 0){
      for(const item of allChartListItems){
        const compareOpt = document.createElement('option');
        compareOpt.value = item.code;
        compareOpt.textContent = `${item.code} ${item.name}`;
        compareSel.appendChild(compareOpt);
      }
      
      if(currentCompare && allChartListItems.some(item => item.code === currentCompare)){
        compareSel.value = currentCompare;
      }
    }
  }
}

async function autoLoadChartList(){
  const el = document.getElementById('autoStatus');
  try{
    el.textContent = "銘柄リストを読み込み中...";
    
    // 225chartlist.csv (225銘柄) を読み込み
    const res225 = await fetch('./225chartlist.csv');
    if(!res225.ok) throw new Error(`225chartlist.csv fetch失敗: ${res225.status} ${res225.statusText}`);
    
    const text225 = await res225.text();
    chartListItems = parseChartList(text225);
    
    if(!Array.isArray(chartListItems) || chartListItems.length === 0){
      throw new Error("225chartlist.csv が空または形式が不正です");
    }
    
    el.textContent = `読込完了,225銘柄=${chartListItems.length}`;

    // 500chartlist.csv (500銘柄) を読み込み
    
    try {
      const res500 = await fetch('./500chartlist.csv');
      if(res500.ok) {
        const text500 = await res500.text();
        chart500ListItems = parseChartList(text500);
      } else {
        console.warn('500chartlist.csv が見つかりません。');
        chart500ListItems = [...chartListItems];
      }
    } catch(e) {
      console.warn('500chartlist.csv の読み込みエラー:', e);
      chart500ListItems = [...chartListItems];
    }
    
    // allchartlist.csv (全銘柄) を読み込み
    try {
      const resAll = await fetch('./allchartlist.csv');
      if(resAll.ok) {
        const textAll = await resAll.text();
        allChartListItems = parseChartList(textAll);
        
        if(Array.isArray(allChartListItems) && allChartListItems.length > 0){
          el.textContent = `読込完了,全銘柄=${allChartListItems.length}`;
        }
      } else {
        console.warn('allchartlist.csv が見つかりません。225銘柄のみ使用します。');
        allChartListItems = [...chartListItems];
      }
    } catch(e) {
      console.warn('allchartlist.csv の読み込みエラー。225銘柄のみ使用します:', e);
      allChartListItems = [...chartListItems];
    }
    
    populateSymbolSelect();
    
    // 初回は最初の銘柄を表示
    const symbolSelect = document.getElementById('symbolSelect');
    if(symbolSelect && symbolSelect.options.length > 1) {
      symbolSelect.selectedIndex = 1;
      await applySymbol();
    }
  }catch(e){
    console.error(e);
    el.textContent = `エラー: ${e.message}`;
  }
}

/* =========================
   Technical Indicators
========================= */
function calculateMA(data, period){
  if(!period || period <= 0){
    return new Array(data.length).fill(null);
  }
  const result = new Array(data.length).fill(null);
  for(let i = period - 1; i < data.length; i++){
    let sum = 0;
    for(let j = 0; j < period; j++) sum += data[i - j].close;
    result[i] = sum / period;
  }
  return result;
}

function calculateEMAValues(values, period){
  const result = new Array(values.length).fill(null);
  if(!period || period <= 0){
    return result;
  }
  const k = 2 / (period + 1);
  let ema = null;

  for(let i = 0; i < values.length; i++){
    const val = values[i];
    if(val == null) continue;
    if(ema == null){
      ema = val;
    }else{
      ema = (val - ema) * k + ema;
    }
    result[i] = ema;
  }
  return result;
}

function calculateEMA(data, period){
  const values = data.map(c => c?.close ?? null);
  return calculateEMAValues(values, period);
}

function calculateRSI(data, period){
  const result = new Array(data.length).fill(null);
  if(data.length <= period) return result;

  let gains = 0, losses = 0;
  for(let i = 1; i <= period; i++){
    const diff = data[i].close - data[i - 1].close;
    if(diff > 0) gains += diff; 
    else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;

  result[period] = (avgLoss === 0) ? 100 : (100 - (100 / (1 + avgGain / avgLoss)));

  for(let i = period + 1; i < data.length; i++){
    const diff = data[i].close - data[i - 1].close;
    const gain = diff > 0 ? diff : 0;
    const loss = diff < 0 ? -diff : 0;

    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;

    result[i] = (avgLoss === 0) ? 100 : (100 - (100 / (1 + avgGain / avgLoss)));
  }
  return result;
}

function calculateMACD(data, shortP, longP, sigP){
  const macdLine = new Array(data.length).fill(null);
  const signalLine = new Array(data.length).fill(null);
  const histogram = new Array(data.length).fill(null);

  const kS = 2 / (shortP + 1), kL = 2 / (longP + 1);

  let emaS = data[0].close;
  let emaL = data[0].close;

  for(let i = 0; i < data.length; i++){
    const price = data[i].close;
    if(i === 0){ 
      emaS = price; 
      emaL = price; 
    }else{
      emaS = (price - emaS) * kS + emaS;
      emaL = (price - emaL) * kL + emaL;
    }
    if(i >= longP - 1) macdLine[i] = emaS - emaL;
  }

  const firstValid = longP - 1;
  if(firstValid < 0 || firstValid >= data.length) 
    return { macd: macdLine, signal: signalLine, hist: histogram };

  let sigEma = macdLine[firstValid];
  const kSig = 2 / (sigP + 1);

  for(let i = firstValid; i < data.length; i++){
    if(i === firstValid){
      signalLine[i] = macdLine[i];
      sigEma = macdLine[i];
    }else{
      sigEma = (macdLine[i] - sigEma) * kSig + sigEma;
      signalLine[i] = sigEma;
    }
    histogram[i] = macdLine[i] - signalLine[i];
  }
  return { macd: macdLine, signal: signalLine, hist: histogram };
}

function calculateStochastic(data, kP, dP){
  const kLine = new Array(data.length).fill(null);
  const dLine = new Array(data.length).fill(null);

  for(let i = kP - 1; i < data.length; i++){
    let highest = -Infinity, lowest = Infinity;
    for(let j = 0; j < kP; j++){
      highest = Math.max(highest, data[i - j].high);
      lowest = Math.min(lowest, data[i - j].low);
    }
    const cur = data[i].close;
    kLine[i] = (highest !== lowest) ? (((cur - lowest) / (highest - lowest)) * 100) : 50;
  }

  for(let i = kP - 1 + dP - 1; i < data.length; i++){
    let sum = 0;
    for(let j = 0; j < dP; j++) sum += kLine[i - j];
    dLine[i] = sum / dP;
  }
  return { k: kLine, d: dLine };
}

function calculateATR(data, period){
  const result = new Array(data.length).fill(null);
  if(data.length < 2) return result;

  // TR%を計算
  const trPercent = new Array(data.length).fill(null);
  for(let i = 1; i < data.length; i++){
    const curr = data[i];
    const prev = data[i - 1];
    
    // TR = max(H-L, |H-PC|, |L-PC|)
    const tr1 = curr.high - curr.low;
    const tr2 = Math.abs(curr.high - prev.close);
    const tr3 = Math.abs(curr.low - prev.close);
    const tr = Math.max(tr1, tr2, tr3);
    
    // TR% = TR / 前日終値
    if(prev.close !== 0){
      trPercent[i] = (tr / prev.close) * 100;
    }
  }

  // ATR% = TR%の移動平均
  for(let i = period; i < data.length; i++){
    let sum = 0;
    let count = 0;
    for(let j = 0; j < period; j++){
      if(trPercent[i - j] != null){
        sum += trPercent[i - j];
        count++;
      }
    }
    if(count > 0){
      result[i] = sum / count;
    }
  }
  
  return result;
}

function calculateATREMA(data, period){
  const trValues = new Array(data.length).fill(null);
  if(data.length < 2) return trValues;

  for(let i = 1; i < data.length; i++){
    const curr = data[i];
    const prev = data[i - 1];

    const tr1 = curr.high - curr.low;
    const tr2 = Math.abs(curr.high - prev.close);
    const tr3 = Math.abs(curr.low - prev.close);
    trValues[i] = Math.max(tr1, tr2, tr3);
  }

  return calculateEMAValues(trValues, period);
}

function calculateKeltner(data, period, multiplier){
  const middle = calculateEMA(data, period);
  const atr = calculateATREMA(data, period);
  const upper = new Array(data.length).fill(null);
  const lower = new Array(data.length).fill(null);

  for(let i = 0; i < data.length; i++){
    if(middle[i] != null && atr[i] != null){
      upper[i] = middle[i] + (atr[i] * multiplier);
      lower[i] = middle[i] - (atr[i] * multiplier);
    }
  }

  return result;
}

function calculateATREMA(data, period){
  const trValues = new Array(data.length).fill(null);
  if(data.length < 2) return trValues;

  for(let i = 1; i < data.length; i++){
    const curr = data[i];
    const prev = data[i - 1];

    const tr1 = curr.high - curr.low;
    const tr2 = Math.abs(curr.high - prev.close);
    const tr3 = Math.abs(curr.low - prev.close);
    trValues[i] = Math.max(tr1, tr2, tr3);
  }

  return calculateEMAValues(trValues, period);
}

function calculateKeltner(data, period, multiplier){
  const middle = calculateEMA(data, period);
  const atr = calculateATREMA(data, period);
  const upper = new Array(data.length).fill(null);
  const lower = new Array(data.length).fill(null);

  for(let i = 0; i < data.length; i++){
    if(middle[i] != null && atr[i] != null){
      upper[i] = middle[i] + (atr[i] * multiplier);
      lower[i] = middle[i] - (atr[i] * multiplier);
    }
  }

  return { upper, middle, lower };
}

function calculateDochian(data, period){
  const high = new Array(data.length).fill(null);
  const low = new Array(data.length).fill(null);
  const mid = new Array(data.length).fill(null);
  if(period <= 0) return { high, low, mid };

  for(let i = period - 1; i < data.length; i++){
    let highest = -Infinity;
    let lowest = Infinity;
    for(let j = 0; j < period; j++){
      const candle = data[i - j];
      if(candle.high != null) highest = Math.max(highest, candle.high);
      if(candle.low != null) lowest = Math.min(lowest, candle.low);
    }
    if(highest !== -Infinity && lowest !== Infinity){
      high[i] = highest;
      low[i] = lowest;
      mid[i] = (highest + lowest) / 2;
    }
  }
  return { high, low, mid };
}

function calculateADX(data, period){
  const adxLine = new Array(data.length).fill(null);
  const plusDI = new Array(data.length).fill(null);
  const minusDI = new Array(data.length).fill(null);
  
  if(data.length < period + 1) return { adx: adxLine, plusDI, minusDI };

  // ① TR, +DM, -DM を計算
  const tr = new Array(data.length).fill(0);
  const plusDM = new Array(data.length).fill(0);
  const minusDM = new Array(data.length).fill(0);

  for(let i = 1; i < data.length; i++){
    const curr = data[i];
    const prev = data[i - 1];
    
    // TR = max(H-L, |H-PC|, |L-PC|)
    const tr1 = curr.high - curr.low;
    const tr2 = Math.abs(curr.high - prev.close);
    const tr3 = Math.abs(curr.low - prev.close);
    tr[i] = Math.max(tr1, tr2, tr3);
    
    // +DM, -DM
    const upMove = curr.high - prev.high;
    const downMove = prev.low - curr.low;
    
    if(upMove > downMove && upMove > 0){
      plusDM[i] = upMove;
    }
    if(downMove > upMove && downMove > 0){
      minusDM[i] = downMove;
    }
  }

  // ③ Wilder方式で平滑化
  const smoothTR = new Array(data.length).fill(null);
  const smoothPlusDM = new Array(data.length).fill(null);
  const smoothMinusDM = new Array(data.length).fill(null);

  // 最初のn期間は単純合計
  let sumTR = 0, sumPlusDM = 0, sumMinusDM = 0;
  for(let i = 1; i <= period; i++){
    sumTR += tr[i];
    sumPlusDM += plusDM[i];
    sumMinusDM += minusDM[i];
  }
  
  smoothTR[period] = sumTR;
  smoothPlusDM[period] = sumPlusDM;
  smoothMinusDM[period] = sumMinusDM;

  // period+1以降はWilder方式で平滑化
  for(let i = period + 1; i < data.length; i++){
    smoothTR[i] = smoothTR[i - 1] - (smoothTR[i - 1] / period) + tr[i];
    smoothPlusDM[i] = smoothPlusDM[i - 1] - (smoothPlusDM[i - 1] / period) + plusDM[i];
    smoothMinusDM[i] = smoothMinusDM[i - 1] - (smoothMinusDM[i - 1] / period) + minusDM[i];
  }

  // ④ +DI, -DI を計算
  for(let i = period; i < data.length; i++){
    if(smoothTR[i] !== 0){
      plusDI[i] = 100 * (smoothPlusDM[i] / smoothTR[i]);
      minusDI[i] = 100 * (smoothMinusDM[i] / smoothTR[i]);
    }
  }

  // ⑤ DX を計算
  const dx = new Array(data.length).fill(null);
  for(let i = period; i < data.length; i++){
    if(plusDI[i] != null && minusDI[i] != null){
      const sum = plusDI[i] + minusDI[i];
      if(sum !== 0){
        dx[i] = 100 * Math.abs(plusDI[i] - minusDI[i]) / sum;
      }
    }
  }

  // ⑥ ADX = DXをWilder方式で平滑化
  // 最初のn期間のDXの平均
  let sumDX = 0;
  let countDX = 0;
  for(let i = period; i < period * 2 && i < data.length; i++){
    if(dx[i] != null){
      sumDX += dx[i];
      countDX++;
    }
  }
  
  if(countDX > 0){
    adxLine[period * 2 - 1] = sumDX / countDX;
  }

  // それ以降はWilder方式で平滑化
  for(let i = period * 2; i < data.length; i++){
    if(adxLine[i - 1] != null && dx[i] != null){
      adxLine[i] = (adxLine[i - 1] * (period - 1) + dx[i]) / period;
    }
  }

  return { adx: adxLine, plusDI, minusDI };
}
// ↓↓↓ ここに追加 ↓↓↓
function calculateVWAP(data, period){
  const result = new Array(data.length).fill(null);
  
  if(period === 0) return result; // 0の場合は非表示
  
  for(let i = period - 1; i < data.length; i++){
    let totalTradingValue = 0;
    let totalVolume = 0;
    
    for(let j = 0; j < period; j++){
      const item = data[i - j];
      if(item.volume != null && item.volume > 0 && item.tradingValue != null){
        totalTradingValue += item.tradingValue;
        totalVolume += item.volume;
      }
    }
    
    if(totalVolume > 0){
      result[i] = totalTradingValue / totalVolume;
    }
  }
  
  return result;
}

function calculateVolumeProfile(visibleIndices, minPrice, maxPrice){
  const bins = 40;
  const profile = new Array(bins).fill(0);
  
  if(minPrice >= maxPrice || !visibleIndices || visibleIndices.length === 0){
    return { bins, profile, minPrice, maxPrice };
  }

  const priceRange = maxPrice - minPrice;
  const binSize = priceRange / bins;
  
  // 各足のVWAP値が属する価格帯に出来高を加算
  visibleIndices.forEach(sIdx => {
    if(sIdx == null) return;
    
    const vwap = indicators.vwap[sIdx];
    const volume = series[sIdx]?.volume;
    
    if(vwap != null && volume != null && volume > 0){
      // VWAPを四捨五入
      const roundedVWAP = Math.round(vwap);
      
      // 四捨五入したVWAPがどの価格帯に属するか計算
      const binIndex = Math.floor((maxPrice - roundedVWAP) / binSize);
      
      // 境界値の処理
      let clampedIndex = binIndex;
      if(roundedVWAP >= maxPrice){
        clampedIndex = 0;
      } else if(roundedVWAP <= minPrice){
        clampedIndex = bins - 1;
      } else {
        clampedIndex = Math.max(0, Math.min(bins - 1, binIndex));
      }
      
      profile[clampedIndex] += volume;
    }
  });
  
  return { bins, profile, minPrice, maxPrice };
}

async function loadFinancialData(code){
  try{
    const res = await fetch(`./financedata/${code}.csv?v=${DATA_VER}`);
    if(!res.ok) return null;
    
    const text = await res.text();
    const lines = text.trim().split(/\r?\n/);
    if(lines.length < 2) return null;
    
    const lastLine = lines[lines.length - 1];
    const cols = lastLine.split(',').map(s => s.trim());
    
    const profit = toNum(cols[3]);
    const eps = toNum(cols[4]);
    
    if(Number.isNaN(profit) || Number.isNaN(eps) || eps === 0) return null;
    
    const shares = profit / eps;
    
    return { eps, shares };
  }catch(e){
    console.log(`財務データ読み込みエラー (${code}):`, e);
    return null;
  }
}

  
function recomputeIndicators(){
  if(!series || series.length === 0){
    indicators.ma1 = []; 
    indicators.ma2 = [];
    indicators.rsi = [];
    indicators.stoch = { k: [], d: [] };
    indicators.macd = { macd: [], signal: [], hist: [] };
    indicators.atr = [];
    indicators.adx = { adx: [], plusDI: [], minusDI: [] };
    indicators.vwap = []; // 追加
    indicators.dochian = { high: [], low: [], mid: [] };
    indicators.keltner = { upper: [], middle: [], lower: [] };
    return;
  }
  indicators.ma1 = calculateMA(series, params.ma1);
  indicators.ma2 = calculateMA(series, params.ma2);
  indicators.rsi = calculateRSI(series, params.rsi);
  indicators.stoch = calculateStochastic(series, params.stochK, params.stochD);
  indicators.macd = calculateMACD(series, params.macdShort, params.macdLong, params.macdSignal);
  indicators.atr = calculateATR(series, params.atr);
  indicators.adx = calculateADX(series, params.adx);
  indicators.vwap = calculateVWAP(series, params.vwap);
  indicators.dochian = calculateDochian(series, params.dochian);
  indicators.keltner = calculateKeltner(series, params.keltner, 2);
}

function calcStatsForVisibleWindow(){
  if(!series || series.length === 0){
    return { winRate: null, upAvg: null, downAvg: null, bullRate: null, totalReturn: null, bullAvg: null, bearAvg: null };
  }

  const { visibleIndices } = getVisibleWindow();
  const idxs = visibleIndices.filter(i => i != null);
  if(idxs.length === 0){
    return { winRate: null, upAvg: null, downAvg: null, bullRate: null, totalReturn: null, bullAvg: null, bearAvg: null };
  }

  let bullN = 0, bullDen = 0;
  let bullSum = 0, bullCnt = 0;
  let bearSum = 0, bearCnt = 0;
  let winN = 0, winDen = 0;
  let upSum = 0, upCnt = 0;
  let downSum = 0, downCnt = 0;
  let firstOpen = null, lastClose = null;
  
  for(let k = 0; k < idxs.length; k++){
    const i = idxs[k];
    const c = series[i];
    if(!c) continue;

    if(firstOpen === null && c.open != null){
      firstOpen = c.open;
    }
    if(c.close != null){
      lastClose = c.close;
    }

    if(c.open != null && c.close != null && c.open !== 0){
      bullDen++;
      const ocPct = ((c.close - c.open) / c.open) * 100;
      
      if(c.close > c.open){
        bullN++;
        bullSum += ocPct;
        bullCnt++;
      }else if(c.close < c.open){
        bearSum += ocPct;
        bearCnt++;
      }
    }

    if(k >= 1){
      const ip = idxs[k - 1];
      const p = series[ip];
      if(p && p.close != null && c.close != null && p.close !== 0){
        const retPct = ((c.close - p.close) / p.close) * 100;

        winDen++;
        if(retPct > 0) winN++;

        if(retPct > 0){
          upSum += retPct; 
          upCnt++;
        }else if(retPct < 0){
          downSum += retPct; 
          downCnt++;
        }
      }
    }
  }

  const bullRate = bullDen > 0 ? (bullN / bullDen) * 100 : null;
  const winRate = winDen > 0 ? (winN / winDen) * 100 : null;
  const upAvg = upCnt > 0 ? (upSum / upCnt) : null;
  const downAvg = downCnt > 0 ? (downSum / downCnt) : null;
  const bullAvg = bullCnt > 0 ? (bullSum / bullCnt) : null;
  const bearAvg = bearCnt > 0 ? (bearSum / bearCnt) : null;
  const totalReturn = (firstOpen != null && lastClose != null && firstOpen !== 0) 
    ? ((lastClose - firstOpen) / firstOpen) * 100 
    : null;

  return { winRate, upAvg, downAvg, bullRate, totalReturn, bullAvg, bearAvg };
}

function calcCorrelationForVisibleWindow(){
  if(!series || series.length === 0 || !compareSeries || compareSeries.length === 0){
    return null;
  }

  const { visibleIndices } = getVisibleWindow();
  const idxs = visibleIndices.filter(i => i != null);
  if(idxs.length === 0){
    return null;
  }

  const compareSeriesDateMap = new Map();
  compareSeries.forEach((item) => {
    if(item && item.date){
      compareSeriesDateMap.set(item.date, item);
    }
  });

  const mainValues = [];
  const compareValues = [];

  idxs.forEach((i) => {
    const mainItem = series[i];
    if(!mainItem || !mainItem.date) return;
    const compareItem = compareSeriesDateMap.get(mainItem.date);
    if(!compareItem) return;

    const mainValue = mainItem.close != null ? mainItem.close : mainItem.open;
    const compareValue = compareItem.close != null ? compareItem.close : compareItem.open;

    if(mainValue == null || compareValue == null) return;
    mainValues.push(mainValue);
    compareValues.push(compareValue);
  });

  if(mainValues.length < 2){
    return null;
  }

  const n = mainValues.length;
  const meanMain = mainValues.reduce((sum, v) => sum + v, 0) / n;
  const meanCompare = compareValues.reduce((sum, v) => sum + v, 0) / n;

  let sumCov = 0;
  let sumMainSq = 0;
  let sumCompareSq = 0;

  for(let i = 0; i < n; i++){
    const mainDiff = mainValues[i] - meanMain;
    const compareDiff = compareValues[i] - meanCompare;
    sumCov += mainDiff * compareDiff;
    sumMainSq += mainDiff * mainDiff;
    sumCompareSq += compareDiff * compareDiff;
  }

  if(sumMainSq === 0 || sumCompareSq === 0){
    return null;
  }

  const corr = sumCov / Math.sqrt(sumMainSq * sumCompareSq);
  return Number(corr.toFixed(2));
}

function clampView(){
  if(!series || series.length === 0){
    displayCount = Math.max(10, displayCount);
    offsetX = 0;
    return;
  }
  const minCount = 10;
  const maxCount = Math.max(minCount, series.length);
  displayCount = Math.max(minCount, Math.min(displayCount, maxCount));

  const maxOffset = Math.max(0, series.length - displayCount);
  offsetX = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
}

function getVisibleWindow(){
  clampView();
  const n = series.length;

  const extraSpace = rightSpaceEnabled ? 5 : 0;

  const startRaw = n - displayCount - offsetX;
  const endRaw = startRaw + displayCount;

  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realSlice = (start < end) ? series.slice(start, end) : [];
  const realLen = realSlice.length;

  const leftPadN = displayCount - realLen;
  const leftPads = new Array(leftPadN).fill(null).map(() => ({ 
    date: "", open: null, high: null, low: null, close: null, volume: null 
  }));

  const rightPads = new Array(extraSpace).fill(null).map(() => ({ 
    date: "", open: null, high: null, low: null, close: null, volume: null 
  }));

  const visibleCandles = leftPads.concat(realSlice, rightPads);

  const visibleIndices = new Array(leftPadN).fill(null).concat(
    Array.from({ length: realLen }, (_, i) => start + i),
    new Array(extraSpace).fill(null)
  );

  return { visibleCandles, visibleIndices, startSeriesIndex: start, endSeriesIndex: end };
}

function updateViewInfo(){
  const el = document.getElementById('viewInfo');
  if(!series || series.length === 0){
    el.textContent = `表示本数: ${displayCount} / 表示範囲: -`;
    return;
  }
  const { visibleCandles } = getVisibleWindow();

  let startDate = null, endDate = null;
  for(let i = 0; i < visibleCandles.length; i++){ 
    if(visibleCandles[i].date){ 
      startDate = visibleCandles[i].date; 
      break; 
    } 
  }
  for(let i = visibleCandles.length - 1; i >= 0; i--){ 
    if(visibleCandles[i].date){ 
      endDate = visibleCandles[i].date; 
      break; 
    } 
  }

  const timeframeLabel = timeframe === 'daily' ? '日足' : timeframe === 'weekly' ? '週足' : '月足';
  el.textContent = `${timeframeLabel} 表示本数: ${displayCount} / 表示範囲: ${startDate && endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}

async function applySymbol(){
  const symbolSelect = document.getElementById('symbolSelect');
  const code = symbolSelect?.value;
  
  if(!code) return;
  
  const selectedOption = symbolSelect?.selectedOptions?.[0];
  currentSymbolDisplay = selectedOption?.textContent || code;
  
  dailySeries = await loadSymbolCSV(code);
  updateTimeframeSeries();

  // 財務情報を読み込み（エラーでも処理を継続）
  try{
    window.currentFinancialData = await loadFinancialData(code);
  }catch(e){
    console.log('財務データ読み込み失敗:', e);
    window.currentFinancialData = null;
  }
  
  offsetX = 0;

  const q = document.getElementById('quickSelect')?.value;
  if(q) displayCount = parseInt(q, 10);

  recomputeIndicators();
  updateViewInfo();
  drawChart();
  
  // 前後の銘柄を先読み
  const modeSelect = document.getElementById('modeSelect');
  const mode = modeSelect?.value || 'all';
  let listItems;
  if (mode === '225') {
    listItems = chartListItems;
  } else if (mode === '500') {
    listItems = chart500ListItems;
  } else {
    listItems = allChartListItems;
  }

  if(listItems) {
    preloadAdjacentSymbols(symbolSelect.selectedIndex, listItems);
  }
}

function updateTimeframeSeries(){
  if(timeframe === 'daily'){
    series = dailySeries;
    compareSeries = compareDailySeries;
  }else if(timeframe === 'weekly'){
    series = convertToWeekly(dailySeries);
    compareSeries = convertToWeekly(compareDailySeries);
  }else if(timeframe === 'monthly'){
    series = convertToMonthly(dailySeries);
    compareSeries = convertToMonthly(compareDailySeries);
  }
}

async function loadCompareSymbol(){
  const compareSel = document.getElementById('compareSymbolSelect');
  const code = compareSel?.value;
  
  if(!code) {
    compareDailySeries = [];
    compareSeries = [];
    compareSymbolCode = "";
    compareSymbolName = "";
    return;
  }
  
  const selectedOption = compareSel?.selectedOptions?.[0];
  compareSymbolName = selectedOption?.textContent || code;
  compareSymbolCode = code;
  
  compareDailySeries = await loadSymbolCSV(code);
  updateTimeframeSeries();
}

function switchTimeframe(newTimeframe){
  if(timeframe === newTimeframe) return;
  
  timeframe = newTimeframe;
  updateTimeframeSeries();
  
  offsetX = 0;
  
  recomputeIndicators();
  updateViewInfo();
  drawChart();
}

function drawChart(){
  if(!mainCanvas) return;

  if(!series || series.length === 0){
    resetBackBuffers();
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.fillStyle = '#666';
    mainCtx.textAlign = 'center';
    mainCtx.fillText("No Data", mainCanvas.width / 2, mainCanvas.height / 2);
    return;
  }

  const { visibleCandles, visibleIndices } = getVisibleWindow();

  drawMain(visibleCandles, visibleIndices);
  drawVolume(visibleCandles, visibleIndices);
  drawMacd(visibleIndices);
  drawStoch(visibleIndices);
  drawRsi(visibleIndices);
  drawAtr(visibleIndices);
  drawAdx(visibleIndices);

  saveBackBuffers();
}

function drawMain(visibleCandles, visibleIndices){
  const ctx = mainCtx;
  const w = mainCanvas.width, h = mainCanvas.height;
  const pad = { t: 20, b: 30, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0, 0, w, h);

  if(currentSymbolDisplay){
    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    if(compareEnabled && compareSymbolCode){
      ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.fillStyle = '#acacac';
      ctx.fillText(currentSymbolDisplay, pad.l + 5, pad.t + 5);
      
      const mainWidth = ctx.measureText(currentSymbolDisplay).width;
      const spaceWidth = ctx.measureText('　').width;
      
      ctx.fillStyle = 'rgba(172, 172, 172, 0.4)';
      ctx.fillText(compareSymbolName, pad.l + 5 + mainWidth + spaceWidth, pad.t + 5);

      const correlation = calcCorrelationForVisibleWindow();
      const correlationText = correlation == null ? '相関係数-' : `相関係数${correlation.toFixed(2)}`;
      ctx.fillStyle = '#acacac';
      ctx.font = '27px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.fillText(correlationText, pad.l + 5, pad.t + 45);
    }else{
      const { winRate, upAvg, downAvg, bullRate, totalReturn, bullAvg, bearAvg } = calcStatsForVisibleWindow();
      
      const fmtPct = (v) => (v == null || Number.isNaN(v)) ? "-" : v.toFixed(1) + "%";
      const fmtAvg = (v) => {
        if(v == null || Number.isNaN(v)) return "-";
        const sign = v >= 0 ? "+" : "";
        return sign + v.toFixed(1) + "%";
      };

      const timeframeLabel = timeframe === 'daily' ? '（日足）' : timeframe === 'weekly' ? '（週足）' : '（月足）';
      
      ctx.fillStyle = '#acacac';
      ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.fillText(currentSymbolDisplay, pad.l + 5, pad.t + 5);
      
      const nameWidth = ctx.measureText(currentSymbolDisplay).width;
      ctx.fillStyle = '#acacac';
      ctx.font = '18px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.fillText(`${timeframeLabel}騰落率${fmtAvg(totalReturn)}`, pad.l + 5 + nameWidth + 10, pad.t + 20);

if(showFinancialInfo){
        const line2 = `勝率${fmtPct(winRate)}（上昇時平均${fmtAvg(upAvg)}、下落時平均${fmtAvg(downAvg)}）`;
        ctx.fillText(line2, pad.l + 5, pad.t + 45);
        
        const line3 = `陽線率${fmtPct(bullRate)}（陽線時平均${fmtAvg(bullAvg)}、陰線時平均${fmtAvg(bearAvg)}）`;
        ctx.fillText(line3, pad.l + 5, pad.t + 65);
        
        let line4 = "";
        if(window.currentFinancialData && dailySeries && dailySeries.length > 0){
          const { eps, shares } = window.currentFinancialData;
          const latestPrice = dailySeries[dailySeries.length - 1].close;
          
          if(latestPrice && eps && shares){
            const per = latestPrice / eps;
            const perText = `PER${per.toFixed(1)}倍`;
            
            const marketCap = shares * latestPrice;
            let marketCapText = "";
            
            const oku = Math.floor(marketCap / 100000000);
            const chou = Math.floor(oku / 10000);
            const remainOku = oku % 10000;
            
            if(chou > 0){
              marketCapText = `時価総額${chou}兆${remainOku}億円`;
            }else{
              marketCapText = `時価総額${oku}億円`;
            }
            
            line4 = `${perText} ${marketCapText}`;
          }
        }
        
        if(line4){
          ctx.fillText(line4, pad.l + 5, pad.t + 85);
        }
      }
    }
    
    ctx.restore();
  }


    
let minP = Infinity, maxP = -Infinity;
let displaySeries = visibleCandles;
let displayCompareSeries = [];
  
  if(compareEnabled && compareSymbolCode && compareSeries.length > 0){
    let mainFirstOpen = null;
    let compareFirstOpen = null;
    
    const compareSeriesDateMap = new Map();
    compareSeries.forEach((item, idx) => {
      if(item && item.date) {
        compareSeriesDateMap.set(item.date, idx);
      }
    });
    
    for(const idx of visibleIndices){
      if(idx != null && series[idx] && series[idx].open != null){
        mainFirstOpen = series[idx].open;
        
        const compareIdx = compareSeriesDateMap.get(series[idx].date);
        if(compareIdx != null && compareSeries[compareIdx] && compareSeries[compareIdx].open != null){
          compareFirstOpen = compareSeries[compareIdx].open;
        }
        break;
      }
    }
    
    if(!compareFirstOpen && compareSeries.length > 0){
      for(let i = 0; i < compareSeries.length; i++){
        if(compareSeries[i] && compareSeries[i].open != null){
          compareFirstOpen = compareSeries[i].open;
          break;
        }
      }
    }
    
    if(mainFirstOpen && mainFirstOpen !== 0 && compareFirstOpen && compareFirstOpen !== 0){
      displaySeries = visibleCandles.map((c, i) => {
        const idx = visibleIndices[i];
        if(idx == null || !series[idx]) return c;
        const original = series[idx];
        if(original.open == null) return c;
        
        return {
          date: original.date,
          open: (original.open / mainFirstOpen) * 100,
          high: original.high != null ? (original.high / mainFirstOpen) * 100 : null,
          low: original.low != null ? (original.low / mainFirstOpen) * 100 : null,
          close: (original.close / mainFirstOpen) * 100,
          volume: original.volume
        };
      });
      
      displayCompareSeries = visibleCandles.map((c, i) => {
        const idx = visibleIndices[i];
        if(idx == null || !series[idx]) return null;
        
        const mainDate = series[idx].date;
        const compareIdx = compareSeriesDateMap.get(mainDate);
        
        if(compareIdx == null || !compareSeries[compareIdx]) return null;
        const original = compareSeries[compareIdx];
        if(original.open == null) return null;
        
        return {
          date: original.date,
          open: (original.open / compareFirstOpen) * 100,
          high: original.high != null ? (original.high / compareFirstOpen) * 100 : null,
          low: original.low != null ? (original.low / compareFirstOpen) * 100 : null,
          close: (original.close / compareFirstOpen) * 100,
          volume: original.volume
        };
      });
      
      displaySeries.forEach((c) => {
        if(!c) return;
        if(c.high != null) maxP = Math.max(maxP, c.high);
        if(c.low != null) minP = Math.min(minP, c.low);
        if(c.open != null){ minP = Math.min(minP, c.open); maxP = Math.max(maxP, c.open); }
        if(c.close != null){ minP = Math.min(minP, c.close); maxP = Math.max(maxP, c.close); }
      });
      
      displayCompareSeries.forEach((c) => {
        if(!c) return;
        if(c.high != null) maxP = Math.max(maxP, c.high);
        if(c.low != null) minP = Math.min(minP, c.low);
        if(c.open != null){ minP = Math.min(minP, c.open); maxP = Math.max(maxP, c.open); }
        if(c.close != null){ minP = Math.min(minP, c.close); maxP = Math.max(maxP, c.close); }
      });
    }
  }else{
    visibleIndices.forEach((sIdx, i) => {
      const c = visibleCandles[i];

      if(c.high != null) maxP = Math.max(maxP, c.high);
      if(c.low != null) minP = Math.min(minP, c.low);
      if(c.open != null){ minP = Math.min(minP, c.open); maxP = Math.max(maxP, c.open); }
      if(c.close != null){ minP = Math.min(minP, c.close); maxP = Math.max(maxP, c.close); }

      if(sIdx != null){
        if(params.ma1 > 0){
          const m1 = indicators.ma1[sIdx];
          if(m1 != null){ minP = Math.min(minP, m1); maxP = Math.max(maxP, m1); }
        }
        if(params.ma2 > 0){
          const m2 = indicators.ma2[sIdx];
          if(m2 != null){ minP = Math.min(minP, m2); maxP = Math.max(maxP, m2); }
        }
        
        // VWAP追加
        if(params.vwap > 0){
          const vwap = indicators.vwap[sIdx];
          if(vwap != null){ minP = Math.min(minP, vwap); maxP = Math.max(maxP, vwap); }
        }

        if(params.dochianEnabled && params.dochian > 0){
          const dochian = indicators.dochian;
          const dHigh = dochian.high[sIdx];
          const dLow = dochian.low[sIdx];
          const dMid = dochian.mid[sIdx];
          if(dHigh != null){ minP = Math.min(minP, dHigh); maxP = Math.max(maxP, dHigh); }
          if(dLow != null){ minP = Math.min(minP, dLow); maxP = Math.max(maxP, dLow); }
          if(dMid != null){ minP = Math.min(minP, dMid); maxP = Math.max(maxP, dMid); }
        }

        if(params.keltnerEnabled && params.keltner > 0){
          const keltner = indicators.keltner;
          const kUpper = keltner.upper[sIdx];
          const kLower = keltner.lower[sIdx];
          const kMiddle = keltner.middle[sIdx];
          if(kUpper != null){ minP = Math.min(minP, kUpper); maxP = Math.max(maxP, kUpper); }
          if(kLower != null){ minP = Math.min(minP, kLower); maxP = Math.max(maxP, kLower); }
          if(kMiddle != null){ minP = Math.min(minP, kMiddle); maxP = Math.max(maxP, kMiddle); }
        }
      }
    });
  }

  if(minP === Infinity){
    ctx.fillStyle = '#666'; 
    ctx.textAlign = 'center'; 
    ctx.fillText("No Data", w / 2, h / 2);
    return;
  }

  const range = (maxP - minP) || 1;
  minP -= range * 0.05; 
  maxP += range * 0.05;
  const scaleY = chartH / (maxP - minP);

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleCandles.length);
  const getY = (val) => pad.t + chartH - (val - minP) * scaleY;

  const roundPrice = (price) => {
    if(price < 1000) return Math.round(price / 10) * 10;
    if(price < 3000) return Math.round(price / 50) * 50;
    if(price < 5000) return Math.round(price / 100) * 100;
    return Math.round(price / 500) * 500;
  };

  ctx.strokeStyle = '#eee'; 
  ctx.lineWidth = 1;
  const gridSteps = 5;
  for(let i = 0; i <= gridSteps; i++){
    const y = pad.t + (chartH * i / gridSteps);
    const rawPrice = maxP - (maxP - minP) * (i / gridSteps);
    const price = roundPrice(rawPrice);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
    ctx.fillStyle = '#666'; 
    ctx.textAlign = 'left';
    ctx.fillText(price.toLocaleString(), w - pad.r + 5, y + 4);
  }

  mainCanvas.candlePositions = visibleCandles.map((c, i) => ({
    x: getX(i),
    w: chartW / visibleCandles.length,
    vIndex: i,
    seriesIndex: visibleIndices[i]
  }));


  const showMonthStart = displayCount >= 60;
  const datePositions = [];
  const dateLabels = [];
  
  if(timeframe === 'monthly'){
    const allMonthPositions = [];
    const allMonthLabels = [];
    const allMonthNumbers = [];
    
    visibleCandles.forEach((c, i) => {
      if(!c.date) return;
      const dateObj = new Date(c.date);
      const yearMonth = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
      allMonthPositions.push(i);
      allMonthLabels.push(yearMonth);
      allMonthNumbers.push(dateObj.getMonth() + 1);
    });
    
    if(allMonthPositions.length >= 50){
      allMonthPositions.forEach((pos, idx) => {
        const monthNum = allMonthNumbers[idx];
        if(monthNum === 1 || monthNum === 7){
          datePositions.push(pos);
          dateLabels.push(allMonthLabels[idx]);
        }
      });
    }else if(allMonthPositions.length > 20){
      const lastIdx = allMonthPositions.length - 1;
      datePositions.push(allMonthPositions[lastIdx]);
      dateLabels.push(allMonthLabels[lastIdx]);
      
      for(let i = lastIdx - 2; i >= 0; i -= 2){
        datePositions.unshift(allMonthPositions[i]);
        dateLabels.unshift(allMonthLabels[i]);
      }
    }else{
      datePositions.push(...allMonthPositions);
      dateLabels.push(...allMonthLabels);
    }
  }else if(showMonthStart){
    let lastMonth = null;
    const allMonthPositions = [];
    const allMonthLabels = [];
    
    visibleCandles.forEach((c, i) => {
      if(!c.date) return;
      const dateObj = new Date(c.date);
      const currentMonth = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
      
      if(currentMonth !== lastMonth){
        allMonthPositions.push(i);
        allMonthLabels.push(currentMonth);
        lastMonth = currentMonth;
      }
    });
    
    if(allMonthPositions.length >= 20){
      const lastIdx = allMonthPositions.length - 1;
      datePositions.push(allMonthPositions[lastIdx]);
      dateLabels.push(allMonthLabels[lastIdx]);
      
      for(let i = lastIdx - 2; i >= 0; i -= 2){
        datePositions.unshift(allMonthPositions[i]);
        dateLabels.unshift(allMonthLabels[i]);
      }
    }else{
      datePositions.push(...allMonthPositions);
      dateLabels.push(...allMonthLabels);
    }
  }else{
    const interval = Math.ceil(visibleCandles.length / 6);
    for(let i = 0; i < visibleCandles.length; i += interval){
      if(visibleCandles[i].date){
        datePositions.push(i);
        dateLabels.push(visibleCandles[i].date);
      }
    }
  }
  
  if(dateLineEnabled){
    ctx.save();
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    ctx.setLineDash([]);
    
    datePositions.forEach(i => {
      const x = getX(i);
      ctx.beginPath();
      ctx.moveTo(x, pad.t);
      ctx.lineTo(x, pad.t + chartH);
      ctx.stroke();
    });
    ctx.restore();
  }
  
  ctx.fillStyle = '#999';
  ctx.textAlign = 'center';
  datePositions.forEach((pos, idx) => {
    ctx.fillText(dateLabels[idx], getX(pos), h - 5);
  });
  
 // 価格帯別出来高の描画（背景レイヤー）
if(volumeProfileEnabled && !compareEnabled && !compareSymbolCode){
  const volumeProfile = calculateVolumeProfile(visibleIndices, minP, maxP);
  const maxVolume = Math.max(...volumeProfile.profile);
  
  if(maxVolume > 0){
    const maxBarWidth = chartW * 0.5; // チャート幅の50%が最大
    
    ctx.save();
    ctx.fillStyle = '#E0EBEB';
    
    for(let i = 0; i < volumeProfile.bins; i++){
      const vol = volumeProfile.profile[i];
      if(vol === 0) continue;
      
      // 価格帯の上端と下端を計算
      const priceRangePerBin = (maxP - minP) / volumeProfile.bins;
      const priceTop = maxP - (i * priceRangePerBin);
      const priceBottom = maxP - ((i + 1) * priceRangePerBin);
      
      // Y座標に変換（getY関数を使用）
      const yTop = getY(priceTop);
      const yBottom = getY(priceBottom);
      const barHeight = Math.abs(yBottom - yTop);
      
      // 横棒の幅を計算（最大50%）
      const barWidth = (vol / maxVolume) * maxBarWidth;
      
      // 右端から左へ伸びる横棒を描画
      const xRight = w - pad.r;
      const xLeft = xRight - barWidth;
      
      ctx.fillRect(xLeft, Math.min(yTop, yBottom), barWidth, barHeight);
    }
    
    ctx.restore();
  }
}
  
  const bodyW = (chartW / visibleCandles.length) * 0.6;
  ctx.lineWidth = 1;

  if(compareEnabled && displayCompareSeries.length > 0){
    displayCompareSeries.forEach((c, i) => {
      if(!c || c.open == null || c.high == null || c.low == null || c.close == null) return;

      const x = getX(i);
      const yH = getY(c.high);
      const yL = getY(c.low);
      const yO = getY(c.open);
      const yC = getY(c.close);

      const up = c.close >= c.open;
      const col = up ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)';

      ctx.strokeStyle = col;
      ctx.beginPath();
      ctx.moveTo(x, yH);
      ctx.lineTo(x, yL);
      ctx.stroke();

      const top = Math.min(yO, yC);
      const bot = Math.max(yO, yC);
      const height = Math.max(1, bot - top);

      ctx.fillStyle = col;
      ctx.fillRect(x - bodyW / 2, top, bodyW, height);

      ctx.strokeStyle = col;
      ctx.strokeRect(x - bodyW / 2, top, bodyW, height);
    });
  }

  displaySeries.forEach((c, i) => {
    if(c.open == null || c.high == null || c.low == null || c.close == null) return;

    const x = getX(i);
    const yH = getY(c.high);
    const yL = getY(c.low);
    const yO = getY(c.open);
    const yC = getY(c.close);

    const up = c.close >= c.open;
    const col = up ? '#26a69a' : '#ef5350';

    ctx.strokeStyle = col;
    ctx.beginPath();
    ctx.moveTo(x, yH);
    ctx.lineTo(x, yL);
    ctx.stroke();

    const top = Math.min(yO, yC);
    const bot = Math.max(yO, yC);
    const height = Math.max(1, bot - top);

    ctx.fillStyle = col;
    ctx.fillRect(x - bodyW / 2, top, bodyW, height);

    ctx.strokeStyle = col;
    ctx.strokeRect(x - bodyW / 2, top, bodyW, height);
  });

  const drawLine = (arr, color, width = 1.5) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = width;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else{
        m = false;
      }
    });
    ctx.stroke();
  };
  
  if(!compareEnabled || !compareSymbolCode){
    if(params.ma1 > 0){
      drawLine(indicators.ma1, '#ff9800');
    }
    if(params.ma2 > 0){
      drawLine(indicators.ma2, '#2196f3');
    }
    
    // VWAP描画追加
    if(params.vwap > 0){
      drawLine(indicators.vwap, '#9c27b0');
    }

    if(params.dochianEnabled && params.dochian > 0){
      drawLine(indicators.dochian.high, '#000', 0.8);
      drawLine(indicators.dochian.low, '#000', 0.8);
      drawLine(indicators.dochian.mid, '#000', 0.8);
    }

    if(params.keltnerEnabled && params.keltner > 0){
      drawLine(indicators.keltner.upper, '#ff0000', 0.8);
      drawLine(indicators.keltner.lower, '#ff0000', 0.8);
      drawLine(indicators.keltner.middle, '#ff0000', 0.8);
    }
  }
}

function drawVolume(visibleCandles, visibleIndices){
  if(collapsed.volume) return;
  const ctx = volumeCtx;
  const w = volumeCanvas.width, h = volumeCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  let maxVol = 0;
  visibleCandles.forEach(c => {
    if(c.volume != null && c.volume > maxVol) maxVol = c.volume;
  });

  if(maxVol === 0) maxVol = 1;
  const scaleY = chartH / maxVol;

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleCandles.length);
  const getY = (vol) => pad.t + chartH - (vol * scaleY);

  const barW = (chartW / visibleCandles.length) * 0.7;

  visibleCandles.forEach((c, i) => {
    if(c.volume == null || c.volume === 0) return;
    
    const x = getX(i);
    const y = getY(c.volume);
    const y0 = pad.t + chartH;

    let color = '#999';
    if(c.open != null && c.close != null){
      color = c.close >= c.open ? '#26a69a' : '#ef5350';
    }

    ctx.fillStyle = color;
    ctx.fillRect(x - barW / 2, y, barW, y0 - y);
  });

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`出来高`, 5, 10);
}

function drawMacd(visibleIndices){
  if(collapsed.macd) return;
  const ctx = macdCtx;
  const w = macdCanvas.width, h = macdCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.macd;
  let minV = Infinity, maxV = -Infinity;

  visibleIndices.forEach(sIdx => {
    if(sIdx == null) return;
    const m = data.macd[sIdx], s = data.signal[sIdx], hi = data.hist[sIdx];
    if(m != null){ minV = Math.min(minV, m); maxV = Math.max(maxV, m); }
    if(s != null){ minV = Math.min(minV, s); maxV = Math.max(maxV, s); }
    if(hi != null){ minV = Math.min(minV, hi); maxV = Math.max(maxV, hi); }
  });

  if(minV === Infinity){ minV = -1; maxV = 1; }
  const range = Math.max(0.0001, maxV - minV);
  const scaleY = chartH / range;

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v - minV) * scaleY;

  const y0 = getY(0);
  ctx.strokeStyle = '#ccc'; 
  ctx.beginPath(); 
  ctx.moveTo(pad.l, y0); 
  ctx.lineTo(w - pad.r, y0); 
  ctx.stroke();

  const barW = (chartW / visibleIndices.length) * 0.7;
  visibleIndices.forEach((sIdx, i) => {
    if(sIdx == null) return;
    const v = data.hist[sIdx];
    if(v != null){
      const x = getX(i), y = getY(v);
      ctx.fillStyle = v >= 0 ? '#26a69a' : '#ef5350';
      ctx.fillRect(x - barW / 2, Math.min(y, y0), barW, Math.abs(y - y0));
    }
  });

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else m = false;
    });
    ctx.stroke();
  };
  drawLine(data.macd, '#2196f3');
  drawLine(data.signal, '#ff9800');

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`MACD(${params.macdShort},${params.macdLong},${params.macdSignal})`, 5, 10);
}

function drawStoch(visibleIndices){
  if(collapsed.stoch) return;
  const ctx = stochCtx;
  const w = stochCanvas.width, h = stochCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.stoch;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.strokeStyle = '#eee'; 
  ctx.setLineDash([4, 4]);
  [20, 80].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
  });
  ctx.setLineDash([]);

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else m = false;
    });
    ctx.stroke();
  };
  drawLine(data.k, '#00bcd4');
  drawLine(data.d, '#ff5722');

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`Stoch(${params.stochK},${params.stochD})`, 5, 10);
}

function drawRsi(visibleIndices){
  if(collapsed.rsi) return;
  const ctx = rsiCtx;
  const w = rsiCanvas.width, h = rsiCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.rsi;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.fillStyle = 'rgba(156, 39, 176, 0.05)';
  const y70 = getY(70), y30 = getY(30);
  ctx.fillRect(pad.l, y70, chartW, y30 - y70);

  ctx.strokeStyle = '#ccc'; 
  ctx.setLineDash([4, 4]);
  [30, 70].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
  });
  ctx.setLineDash([]);

  ctx.strokeStyle = '#9c27b0'; 
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  let m = false;
  visibleIndices.forEach((sIdx, i) => {
    if(sIdx == null){ m = false; return; }
    const v = data[sIdx];
    if(v != null){
      const x = getX(i), y = getY(v);
      if(!m){ ctx.moveTo(x, y); m = true; } 
      else ctx.lineTo(x, y);
    }else m = false;
  });
  ctx.stroke();

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`RSI(${params.rsi})`, 5, 10);
}

function drawAtr(visibleIndices){
  if(collapsed.atr) return;
  const ctx = atrCtx;
  const w = atrCanvas.width, h = atrCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.atr;
  let minV = Infinity, maxV = -Infinity;

  visibleIndices.forEach(sIdx => {
    if(sIdx == null) return;
    const v = data[sIdx];
    if(v != null){
      minV = Math.min(minV, v);
      maxV = Math.max(maxV, v);
    }
  });

  if(minV === Infinity){ minV = 0; maxV = 5; }
  const range = Math.max(0.0001, maxV - minV);
  minV = Math.max(0, minV - range * 0.1);
  maxV = maxV + range * 0.1;
  const scaleY = chartH / (maxV - minV);

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v - minV) * scaleY;

  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for(let i = 0; i <= 5; i++){
    const y = pad.t + (chartH * i / 5);
    const val = maxV - (maxV - minV) * (i / 5);
    ctx.beginPath();
    ctx.moveTo(pad.l, y);
    ctx.lineTo(w - pad.r, y);
    ctx.stroke();
    ctx.fillStyle = '#666';
    ctx.textAlign = 'left';
    ctx.fillText(val.toFixed(2) + '%', w - pad.r + 5, y + 4);
  }

  ctx.strokeStyle = '#e91e63';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  let m = false;
  visibleIndices.forEach((sIdx, i) => {
    if(sIdx == null){ m = false; return; }
    const v = data[sIdx];
    if(v != null){
      const x = getX(i), y = getY(v);
      if(!m){ ctx.moveTo(x, y); m = true; }
      else ctx.lineTo(x, y);
    }else m = false;
  });
  ctx.stroke();

  ctx.fillStyle = '#666';
  ctx.textAlign = 'left';
  ctx.fillText(`ATR%(${params.atr})`, 5, 10);
}

function drawAdx(visibleIndices){
  if(collapsed.adx) return;
  const ctx = adxCtx;
  const w = adxCanvas.width, h = adxCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.adx;
  let minV = Infinity, maxV = -Infinity;

  visibleIndices.forEach(sIdx => {
    if(sIdx == null) return;
    const adx = data.adx[sIdx];
    const pdi = data.plusDI[sIdx];
    const mdi = data.minusDI[sIdx];
    if(adx != null){ minV = Math.min(minV, adx); maxV = Math.max(maxV, adx); }
    if(pdi != null){ minV = Math.min(minV, pdi); maxV = Math.max(maxV, pdi); }
    if(mdi != null){ minV = Math.min(minV, mdi); maxV = Math.max(maxV, mdi); }
  });

  if(minV === Infinity){ minV = 0; maxV = 100; }
  const range = Math.max(0.0001, maxV - minV);
  minV = Math.max(0, minV - range * 0.1);
  maxV = Math.min(100, maxV + range * 0.1);
  const scaleY = chartH / (maxV - minV);

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v - minV) * scaleY;

  // グリッド線
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 1;
  for(let i = 0; i <= 5; i++){
    const y = pad.t + (chartH * i / 5);
    const val = maxV - (maxV - minV) * (i / 5);
    ctx.beginPath();
    ctx.moveTo(pad.l, y);
    ctx.lineTo(w - pad.r, y);
    ctx.stroke();
    ctx.fillStyle = '#666';
    ctx.textAlign = 'left';
    ctx.fillText(val.toFixed(1), w - pad.r + 5, y + 4);
  }

  // 25の参照線（ADXの重要ライン）
  if(minV <= 25 && maxV >= 25){
    const y25 = getY(25);
    ctx.strokeStyle = '#ccc';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad.l, y25);
    ctx.lineTo(w - pad.r, y25);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  const drawLine = (arr, color, lineWidth = 1.5) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; }
        else ctx.lineTo(x, y);
      }else m = false;
    });
    ctx.stroke();
  };

  // +DI (緑), -DI (青), ADX (赤・太い)
  drawLine(data.plusDI, '#4caf50', 2);
  drawLine(data.minusDI, '#2196f3', 2);
  drawLine(data.adx, '#f44336', 2.5);

  ctx.fillStyle = '#666';
  ctx.textAlign = 'left';
  ctx.fillText(`ADX(${params.adx})`, 5, 10);
  
  // 凡例
  ctx.fillStyle = '#4caf50';
  ctx.fillText('+DI', 80, 10);
  ctx.fillStyle = '#2196f3';
  ctx.fillText('-DI', 120, 10);
  ctx.fillStyle = '#f44336';
  ctx.fillText('ADX', 160, 10);
}

function drawCrosshair(x){
  restoreBackBuffers();
  if(x < 0) return;
  const draw = (ctx, h) => {
    if(!ctx) return;
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.setLineDash([3, 3]);
    ctx.beginPath(); 
    ctx.moveTo(x, 0); 
    ctx.lineTo(x, h); 
    ctx.stroke();
    ctx.restore();
  };
  draw(mainCtx, mainCanvas.height);
  if(!collapsed.volume) draw(volumeCtx, volumeCanvas.height);
  if(!collapsed.macd) draw(macdCtx, macdCanvas.height);
  if(!collapsed.stoch) draw(stochCtx, stochCanvas.height);
  if(!collapsed.rsi) draw(rsiCtx, rsiCanvas.height);
  if(!collapsed.atr) draw(atrCtx, atrCanvas.height);
  if(!collapsed.adx) draw(adxCtx, adxCanvas.height);
}

function handleTooltip(e, canvas){
  if(!mainCanvas.candlePositions || !series || series.length === 0) return;

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;

  const p = mainCanvas.candlePositions.find(pp => 
    mouseX >= pp.x - pp.w / 2 && mouseX <= pp.x + pp.w / 2
  );
  if(!p){
    tooltip.style.display = 'none';
    drawCrosshair(-1);
    return;
  }

  const sIdx = p.seriesIndex;
  if(sIdx == null){
    tooltip.style.display = 'none';
    drawCrosshair(p.x);
    return;
  }

  const c = series[sIdx];
  const fmt = n => (n !== null && n !== undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined, { maximumFractionDigits: 2 })
    : '-';

  const ma1 = indicators.ma1[sIdx], ma2 = indicators.ma2[sIdx];
  const rsi = indicators.rsi[sIdx];
  const stK = indicators.stoch.k[sIdx], stD = indicators.stoch.d[sIdx];
  const macd = indicators.macd.macd[sIdx], sig = indicators.macd.signal[sIdx];
  const atr = indicators.atr[sIdx];
  const adx = indicators.adx.adx[sIdx];
  const plusDI = indicators.adx.plusDI[sIdx];
  const minusDI = indicators.adx.minusDI[sIdx];
  const vwap = indicators.vwap[sIdx]; // 追加

  const timeframeLabel = timeframe === 'daily' ? '（日足）' : timeframe === 'weekly' ? '（週足）' : '（月足）';

  let html = `<strong>${c.date}${timeframeLabel}</strong><br>`;
  html += `始:${fmt(c.open)} 高:${fmt(c.high)} 安:${fmt(c.low)} 終:${fmt(c.close)}<br>`;
  if(c.volume != null){
    html += `出来高:${fmt(c.volume)}<br>`;
  }
  if(params.ma1 > 0 || params.ma2 > 0){
    const ma1Label = params.ma1 > 0 ? `<span style="color:#ff9800">MA${params.ma1}:${fmt(ma1)}</span>` : '';
    const ma2Label = params.ma2 > 0 ? `<span style="color:#2196f3">MA${params.ma2}:${fmt(ma2)}</span>` : '';
    html += `${ma1Label}${ma1Label && ma2Label ? ' ' : ''}${ma2Label}<br>`;
  }
  html += `<span style="color:#9c27b0">VWAP:${fmt(vwap)}</span><br>`; // 追加
  html += `<span style="color:#9c27b0">RSI:${fmt(rsi)}</span><br>`;
  html += `<span style="color:#00bcd4">K:${fmt(stK)}</span> <span style="color:#ff5722">D:${fmt(stD)}</span><br>`;
  html += `MACD:${fmt(macd)} Sig:${fmt(sig)}<br>`;
  html += `<span style="color:#e91e63">ATR%:${fmt(atr)}</span><br>`;
  html += `<span style="color:#f44336">ADX:${fmt(adx)}</span> <span style="color:#4caf50">+DI:${fmt(plusDI)}</span> <span style="color:#2196f3">-DI:${fmt(minusDI)}</span>`;

  tooltip.innerHTML = html;
  tooltip.style.display = 'block';

  let tx = e.clientX + 15, ty = e.clientY + 15;
  if(tx + 150 > window.innerWidth) tx -= 160;
  tooltip.style.left = tx + 'px';
  tooltip.style.top = ty + 'px';

  drawCrosshair(p.x);
}

function onWheelZoom(e){
  e.preventDefault();
  if(!series || series.length === 0) return;

  const shrink = (e.deltaY < 0);
  displayCount += (shrink ? -1 : +1);

  clampView();
  updateViewInfo();

  const qs = document.getElementById('quickSelect');
  if(qs) qs.value = "";

  drawChart();
}

function onMouseDown(e, cvs){
  if(!series || series.length === 0) return;
  isDragging = true;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}

function onMouseMove(e, cvs){
  if(!series || series.length === 0) return;

  if(isDragging){
    const rect = cvs.getBoundingClientRect();
    const w = rect.width - 100;
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, w / displayCount);
    const candleMove = diffX / ppc;

    let newOffset = dragStartOffset + candleMove;
    const maxOffset = Math.max(0, series.length - displayCount);
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = newOffset;

    updateViewInfo();
    drawChart();
  }else{
    handleTooltip(e, cvs);
  }
}

function onMouseUp(){
  isDragging = false;
  document.body.style.cursor = 'default';
}

function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display = 'none';
  drawCrosshair(-1);
}

function toggleIndicator(key){
  collapsed[key] = !collapsed[key];
  const wrapper = document.getElementById(key + 'Wrapper');
  const collapseBtn = document.getElementById(key + 'CollapseBtn');
  const expandBtn = document.getElementById(key + 'ExpandBtn');
  
  if(collapsed[key]){
    wrapper.classList.add('collapsed');
    collapseBtn.style.display = 'none';
    expandBtn.style.display = 'flex';
  }else{
    wrapper.classList.remove('collapsed');
    collapseBtn.style.display = 'flex';
    expandBtn.style.display = 'none';
  }
  setTimeout(resizeCanvas, 210);
}

function toggleParams(){
  const wrapper = document.getElementById('paramsWrapper');
  const collapseBtn = document.getElementById('paramsCollapseBtn');
  const expandBtn = document.getElementById('paramsExpandBtn');
  
  if(wrapper.classList.contains('collapsed')){
    wrapper.classList.remove('collapsed');
    collapseBtn.style.display = 'flex';
    expandBtn.style.display = 'none';
  }else{
    wrapper.classList.add('collapsed');
    collapseBtn.style.display = 'none';
    expandBtn.style.display = 'flex';
  }
}

function toggleLegend(){
  const wrapper = document.getElementById('legendWrapper');
  const collapseBtn = document.getElementById('legendCollapseBtn');
  const expandBtn = document.getElementById('legendExpandBtn');
  
  if(wrapper.classList.contains('collapsed')){
    wrapper.classList.remove('collapsed');
    collapseBtn.style.display = 'flex';
    expandBtn.style.display = 'none';
  }else{
    wrapper.classList.add('collapsed');
    collapseBtn.style.display = 'none';
    expandBtn.style.display = 'flex';
  }
}

function moveIndicator(key, dir){
  const container = document.getElementById(key + 'Container');
  const parent = document.getElementById('indicatorsList');
  if(dir === 'up'){
    const prev = container.previousElementSibling;
    if(prev) parent.insertBefore(container, prev);
  }else{
    const next = container.nextElementSibling;
    if(next) parent.insertBefore(next, container);
  }
  setTimeout(resizeCanvas, 0);
}

function moveIndicator(key, dir){
  const container = document.getElementById(key + 'Container');
  const parent = document.getElementById('indicatorsList');
  if(dir === 'up'){
    const prev = container.previousElementSibling;
    if(prev) parent.insertBefore(container, prev);
  }else{
    const next = container.nextElementSibling;
    if(next) parent.insertBefore(next, container);
  }
  setTimeout(resizeCanvas, 0);
}

function resizeCanvas(){
  resetBackBuffers();
  const resize = (c) => {
    if(!c) return;
    const rect = c.getBoundingClientRect();
    c.width = rect.width; 
    c.height = rect.height;
  };
  resize(mainCanvas); 
  resize(volumeCanvas); 
  resize(macdCanvas); 
  resize(stochCanvas); 
  resize(rsiCanvas);
  resize(atrCanvas);
  resize(adxCanvas);
  drawChart();
}

function setupEventListeners(){
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const helpCloseBtn = document.getElementById('helpCloseBtn');
  const openHelp = () => { 
    helpModal.style.display = 'flex'; 
    helpModal.setAttribute('aria-hidden', 'false'); 
  };
  const closeHelp = () => { 
    helpModal.style.display = 'none'; 
    helpModal.setAttribute('aria-hidden', 'true'); 
  };
  helpBtn.addEventListener('click', openHelp);
  helpCloseBtn.addEventListener('click', closeHelp);
  helpModal.addEventListener('click', (e) => { 
    if(e.target === helpModal) closeHelp(); 
  });
  window.addEventListener('keydown', (e) => { 
    if(e.key === 'Escape' && helpModal.style.display === 'flex') closeHelp(); 
  });
  // 矢印ボタンのイベント（押しっぱなし対応）
  let arrowInterval = null;
  
  const moveStock = (direction) => {
    const symbolSelect = document.getElementById('symbolSelect');
    if(!symbolSelect) return;
    
    const currentIndex = symbolSelect.selectedIndex;
    const maxIndex = symbolSelect.options.length - 1;
    let newIndex = currentIndex;
    
    if(direction === 'prev' && currentIndex > 0) {
      newIndex = currentIndex - 1;
    } else if(direction === 'next' && currentIndex < maxIndex) {
      newIndex = currentIndex + 1;
    }
    
    if(newIndex !== currentIndex) {
      symbolSelect.selectedIndex = newIndex;
      applySymbol();
    }
  };
  
  const startArrowRepeat = (direction) => {
    moveStock(direction); // 即座に1回実行
    arrowInterval = setInterval(() => moveStock(direction), 150); // 150ms間隔で連続実行
  };
  
  const stopArrowRepeat = () => {
    if(arrowInterval) {
      clearInterval(arrowInterval);
      arrowInterval = null;
    }
  };
  
  // 前へボタン
  const prevBtn = document.getElementById('prevStockBtn');
  if(prevBtn) {
    prevBtn.addEventListener('mousedown', () => startArrowRepeat('prev'));
    prevBtn.addEventListener('mouseup', stopArrowRepeat);
    prevBtn.addEventListener('mouseleave', stopArrowRepeat);
    prevBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startArrowRepeat('prev'); });
    prevBtn.addEventListener('touchend', stopArrowRepeat);
  }
  
  // 次へボタン
  const nextBtn = document.getElementById('nextStockBtn');
  if(nextBtn) {
    nextBtn.addEventListener('mousedown', () => startArrowRepeat('next'));
    nextBtn.addEventListener('mouseup', stopArrowRepeat);
    nextBtn.addEventListener('mouseleave', stopArrowRepeat);
    nextBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startArrowRepeat('next'); });
    nextBtn.addEventListener('touchend', stopArrowRepeat);
  }
  
  // モード切替のイベント
  document.getElementById('modeSelect')?.addEventListener('change', () => {
    populateSymbolSelect();
  });

  // 銘柄選択のイベント
  document.getElementById('symbolSelect')?.addEventListener('change', () => applySymbol());

  document.getElementById('symbolSelect')?.addEventListener('keydown', (e) => {
    const sel = e.target;
    const currentIndex = sel.selectedIndex;
    const maxIndex = sel.options.length - 1;
    let newIndex = currentIndex;

    if(e.key === 'ArrowRight'){
      e.preventDefault();
      newIndex = Math.min(currentIndex + 1, maxIndex);
    }else if(e.key === 'ArrowLeft'){
      e.preventDefault();
      newIndex = Math.max(currentIndex - 1, 0);
    }else if(e.key === 'ArrowDown'){
      e.preventDefault();
      newIndex = Math.min(currentIndex + 10, maxIndex);
    }else if(e.key === 'ArrowUp'){
      e.preventDefault();
      newIndex = Math.max(currentIndex - 10, 0);
    }

    if(newIndex !== currentIndex){
      sel.selectedIndex = newIndex;
      applySymbol();
    }
  });

  document.getElementById('quickSelect')?.addEventListener('change', (e) => {
    const v = e.target.value;
    if(!v) return;
    displayCount = parseInt(v, 10);
    offsetX = 0;
    clampView();
    updateViewInfo();
    drawChart();
  });

  document.getElementById('rightSpaceCheck')?.addEventListener('change', (e) => {
    rightSpaceEnabled = e.target.checked;
    drawChart();
  });

  document.getElementById('dateLineCheck')?.addEventListener('change', (e) => {
    dateLineEnabled = e.target.checked;
    drawChart();
  });

  document.getElementById('volumeProfileCheck')?.addEventListener('change', (e) => {
    volumeProfileEnabled = e.target.checked;
    drawChart();
  });

  document.getElementById('financialInfoCheck')?.addEventListener('change', (e) => {
    showFinancialInfo = e.target.checked;
    drawChart();
  });

  document.getElementById('compareCheck')?.addEventListener('change', async (e) => {
    compareEnabled = e.target.checked;
    if(compareEnabled){
      await loadCompareSymbol();
    }else{
      compareSymbolCode = "";
      compareSymbolName = "";
      compareSeries = [];
      compareDailySeries = [];
    }
    drawChart();
  });

  document.getElementById('compareSymbolSelect')?.addEventListener('change', async (e) => {
    if(compareEnabled){
      await loadCompareSymbol();
      drawChart();
    }
  });

  const dailyCheck = document.getElementById('dailyCheck');
  const weeklyCheck = document.getElementById('weeklyCheck');
  const monthlyCheck = document.getElementById('monthlyCheck');

  dailyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      weeklyCheck.checked = false;
      monthlyCheck.checked = false;
      switchTimeframe('daily');
    }else{
      e.target.checked = true;
    }
  });

  weeklyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      dailyCheck.checked = false;
      monthlyCheck.checked = false;
      switchTimeframe('weekly');
    }else{
      e.target.checked = true;
    }
  });

  monthlyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      dailyCheck.checked = false;
      weeklyCheck.checked = false;
      switchTimeframe('monthly');
    }else{
      e.target.checked = true;
    }
  });

  const inputs = document.querySelectorAll('.param-group input[type="number"]');
  inputs.forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.id;
      const val = parseInt(e.target.value, 10);
      if(!(val >= 0)) return;

      if(id === 'ma1Period') params.ma1 = val;
      if(id === 'ma2Period') params.ma2 = val;
      if(id === 'vwapPeriod') params.vwap = val;
      if(id === 'rsiPeriod') params.rsi = val;
      if(id === 'stochK') params.stochK = val;
      if(id === 'stochD') params.stochD = val;
      if(id === 'macdShort') params.macdShort = val;
      if(id === 'macdLong') params.macdLong = val;
      if(id === 'macdSignal') params.macdSignal = val;
      if(id === 'atrPeriod') params.atr = val;
      if(id === 'adxPeriod') params.adx = val;
      if(id === 'dochianPeriod') params.dochian = val;
      if(id === 'keltnerPeriod') params.keltner = val;

      recomputeIndicators();
      drawChart();
    });
  });

  const dochianCheck = document.getElementById('dochianCheck');
  dochianCheck?.addEventListener('change', (e) => {
    params.dochianEnabled = e.target.checked;
    drawChart();
  });

  const keltnerCheck = document.getElementById('keltnerCheck');
  keltnerCheck?.addEventListener('change', (e) => {
    params.keltnerEnabled = e.target.checked;
    drawChart();
  });

  const canvases = [mainCanvas, volumeCanvas, macdCanvas, stochCanvas, rsiCanvas, atrCanvas, adxCanvas];
  canvases.forEach(cvs => {
    if(!cvs) return;

    cvs.addEventListener('wheel', onWheelZoom, { passive: false });
    cvs.addEventListener('mousedown', (e) => onMouseDown(e, cvs));
    cvs.addEventListener('mousemove', (e) => onMouseMove(e, cvs));
    cvs.addEventListener('mouseup', onMouseUp);
    cvs.addEventListener('mouseleave', onMouseLeave);
  });

  window.addEventListener('resize', resizeCanvas);
  // グローバルな矢印キーイベント（入力欄以外で有効）
  window.addEventListener('keydown', (e) => {
    // フォーカスされている要素を確認
    const activeElement = document.activeElement;
    const tagName = activeElement.tagName.toLowerCase();
    
    // input, select, textareaの場合は何もしない（干渉を避ける）
    if(tagName === 'input' || tagName === 'select' || tagName === 'textarea'){
      return;
    }
    
    // 矢印キーの場合のみ処理
    if(!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)){
      return;
    }
    
    const symbolSelect = document.getElementById('symbolSelect');
    if(!symbolSelect) return;
    
    e.preventDefault(); // デフォルトのスクロール動作を防止
    
    const currentIndex = symbolSelect.selectedIndex;
    const maxIndex = symbolSelect.options.length - 1;
    let newIndex = currentIndex;

    if(e.key === 'ArrowRight'){
      newIndex = Math.min(currentIndex + 1, maxIndex);
    }else if(e.key === 'ArrowLeft'){
      newIndex = Math.max(currentIndex - 1, 0);
    }else if(e.key === 'ArrowDown'){
      newIndex = Math.min(currentIndex + 10, maxIndex);
    }else if(e.key === 'ArrowUp'){
      newIndex = Math.max(currentIndex - 10, 0);
    }

    if(newIndex !== currentIndex){
      symbolSelect.selectedIndex = newIndex;
      applySymbol();
    }
  });
}



function init(){
  mainCanvas = document.getElementById('mainChart');
  mainCtx = mainCanvas.getContext('2d');

  volumeCanvas = document.getElementById('volumeChart');
  volumeCtx = volumeCanvas.getContext('2d');

  macdCanvas = document.getElementById('macdChart');
  macdCtx = macdCanvas.getContext('2d');

  stochCanvas = document.getElementById('stochChart');
  stochCtx = stochCanvas.getContext('2d');

  rsiCanvas = document.getElementById('rsiChart');
  rsiCtx = rsiCanvas.getContext('2d');

  atrCanvas = document.getElementById('atrChart');
  atrCtx = atrCanvas.getContext('2d');

  adxCanvas = document.getElementById('adxChart');
  adxCtx = adxCanvas.getContext('2d');

  tooltip = document.getElementById('tooltip');

  setupEventListeners();
  resizeCanvas();
  autoLoadChartList();
}

window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>



















