<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>225爆速チャートくん</title>
  <style>
    body { margin: 0; padding: 1rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: #f5f5f5; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 2rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }

    .title-row{ display:flex; align-items:baseline; gap:10px; }
    h1 { margin: 0; font-size: 1.5rem; color: #333; }
    .help-btn{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .help-btn:hover{ background:#d5d5d5; }

    .modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal{ width:min(720px, calc(100vw - 40px)); background:#fff; border:1px solid #ccc; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.25); padding:14px 16px; }
    .modal-header{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
    .modal-title{ font-size:14px; font-weight:700; margin:0; }
    .modal-close{ font-size:12px; padding:3px 8px; background:#e0e0e0; color:#000; border:1px solid #bdbdbd; border-radius:4px; cursor:pointer; }
    .modal-close:hover{ background:#d5d5d5; }
    .modal-body{ font-size:13px; color:#333; line-height:1.7; white-space:pre-line; }

    .controls-row { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:15px; align-items:center; padding-bottom:10px; border-bottom:1px solid #eee; }
    .param-group { display:flex; align-items:center; gap:6px; font-size:13px; background:#f9f9f9; padding:4px 8px; border-radius:4px; border:1px solid #eee; }
    .param-group label { font-weight:600; color:#555; }
    .param-group input { width:45px; padding:2px 4px; border:1px solid #ccc; border-radius:3px; text-align:center; }
    .param-group select{ padding:2px 6px; border:1px solid #ccc; border-radius:3px; background:#fff; }

    .hint { font-size:12px; color:#666; }
    .legend { display:flex; gap:15px; font-size:12px; margin-bottom:10px; flex-wrap:wrap; align-items:center; }
    .legend-item { display:flex; align-items:center; gap:4px; }
    .legend-color { width:12px; height:12px; border-radius:2px; }

    canvas { display:block; width:100%; cursor:crosshair; }
    #mainChart { height:350px; border:1px solid #ddd; border-bottom:none; position:relative; }

    .indicator-container { border:1px solid #ddd; border-top:none; background:#fff; position:relative; min-height:24px; }
    .indicator-controls { position:absolute; top:2px; right:2px; pointer-events:auto; display:flex; gap:2px; z-index:10; }
    .btn-icon { width:16px; height:16px; border:none; color:#fff; font-size:10px; line-height:1; cursor:pointer; display:flex; align-items:center; justify-content:center; border-radius:2px; opacity:0.7; }
    .btn-icon:hover { opacity:1; }
    .btn-move { background:#2196f3; }
    .btn-toggle { background:#666; }
    .btn-expand { background:#4caf50; }
    .indicator-wrapper { height:120px; transition:height 0.2s; overflow:hidden; }
    .indicator-wrapper.collapsed { height:0; }
    .indicator-canvas { height:100%; width:100%; }

    .tooltip { position:absolute; background:rgba(255,255,255,0.95); border:1px solid #999; padding:8px; border-radius:4px; font-size:12px; pointer-events:none; display:none; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:100; line-height:1.4; white-space:nowrap; }
  </style>
</head>
<body>

<div class="container">
  <div class="title-row">
    <h1>爆速チャートくん225</h1>
    <button id="helpBtn" class="help-btn" type="button">説明</button>
  </div>

  <div class="controls-row" style="margin-top:15px;">
    <div class="param-group">
      <label>銘柄</label>
      <select id="symbolSelect">
        <option value="">読み込み中...</option>
      </select>
    </div>

    <div class="param-group">
      <label>期間変更</label>
      <select id="quickSelect" title="表示本数を即変更">
        <option value="">-</option>
        <option value="20">20</option>
        <option value="100" selected>100</option>
        <option value="200">200</option>
        <option value="500">500</option>
        <option value="1000">1000</option>
      </select>
    </div>

    <span id="autoStatus" class="hint">chartlist.csv を読込中...</span>
    <span id="status" class="hint" style="margin-left:auto;"></span>
  </div>

  <div class="controls-row">
    <span class="hint" id="viewInfo">表示本数: - / 表示範囲: -</span>
    <span class="hint" style="margin-left:auto;">矢印ボタンで銘柄高速切替、ホイール拡大縮小、ドラッグ左右移動</span>
  </div>

  <div class="controls-row">
    <div class="param-group"><label>MA1</label><input type="number" id="ma1Period" value="20"></div>
    <div class="param-group"><label>MA2</label><input type="number" id="ma2Period" value="60"></div>
    <div class="param-group"><label>RSI</label><input type="number" id="rsiPeriod" value="14"></div>
    <div class="param-group"><label>Stoch K</label><input type="number" id="stochK" value="14"></div>
    <div class="param-group"><label>Stoch D</label><input type="number" id="stochD" value="3"></div>
    <div class="param-group"><label>MACD S</label><input type="number" id="macdShort" value="12"></div>
    <div class="param-group"><label>MACD L</label><input type="number" id="macdLong" value="26"></div>
    <div class="param-group"><label>Sig</label><input type="number" id="macdSignal" value="9"></div>
  </div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background:#333"></div><span>価格（ローソク足）</span></div>
    <div class="legend-item"><div class="legend-color" style="background:#ff9800"></div>MA1</div>
    <div class="legend-item"><div class="legend-color" style="background:#2196f3"></div>MA2</div>
    <div class="legend-item" style="margin-left:auto; display:flex; gap:10px;">
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="dailyCheck" checked>
        <span>日足</span>
      </label>
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="weeklyCheck">
        <span>週足</span>
      </label>
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="monthlyCheck">
        <span>月足</span>
      </label>
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer;">
        <input type="checkbox" id="rightSpaceCheck">
        <span>右スペース</span>
      </label>
    </div>
  </div>

  <canvas id="mainChart"></canvas>

  <div id="indicatorsList">
    <div class="indicator-container" id="volumeContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('volume','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('volume','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('volume')" id="volumeCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('volume')" id="volumeExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="volumeWrapper">
        <canvas class="indicator-canvas" id="volumeChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="macdContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('macd','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('macd')" id="macdCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('macd')" id="macdExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="macdWrapper">
        <canvas class="indicator-canvas" id="macdChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="stochContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('stoch','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('stoch')" id="stochCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('stoch')" id="stochExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="stochWrapper">
        <canvas class="indicator-canvas" id="stochChart"></canvas>
      </div>
    </div>

    <div class="indicator-container" id="rsiContainer">
      <div class="indicator-controls">
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','up')">▲</button>
        <button class="btn-icon btn-move" onclick="moveIndicator('rsi','down')">▼</button>
        <button class="btn-icon btn-toggle" onclick="toggleIndicator('rsi')" id="rsiCollapseBtn">−</button>
        <button class="btn-icon btn-expand" onclick="toggleIndicator('rsi')" id="rsiExpandBtn" style="display:none;">+</button>
      </div>
      <div class="indicator-wrapper" id="rsiWrapper">
        <canvas class="indicator-canvas" id="rsiChart"></canvas>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>
</div>

<div id="helpModal" class="modal-overlay" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
    <div class="modal-header">
      <p class="modal-title" id="helpModalTitle">使い方</p>
      <button id="helpCloseBtn" class="modal-close" type="button">閉じる</button>
    </div>
    <div class="modal-body">
- 平日18時頃に自動更新。
- 銘柄選択は左右矢印で高速切り替え、左右＝1ずつ、上下＝10ずつ。
- ホイール拡大縮小、ドラッグ左右移動
- 個別CSVファイルから必要な銘柄だけを読み込むことで爆速表示を実現！
- テクニカル指標は表示・非表示・場所入れ替えが可能。数値変更で動的描写。
- 日足・週足・月足の切り替えが可能。
- 公式JPXAPI→個別CSV→HTMLブラウザアプリで表示。    
    </div>
  </div>
</div>

<script>
/* =========================
   State
========================= */
let chartListItems = null;
let symbolCache = new Map(); // code -> daily series data
let dailySeries = []; // 日足データ（オリジナル）
let series = []; // 表示用データ（日足/週足/月足）
let timeframe = 'daily'; // 'daily', 'weekly', 'monthly'
let displayCount = 100;
let offsetX = 0;

let isDragging = false;
let dragStartX = 0;
let dragStartOffset = 0;

let params = {
  ma1: 20, ma2: 60,
  rsi: 14,
  stochK: 14, stochD: 3,
  macdShort: 12, macdLong: 26, macdSignal: 9
};

let mainCanvas, mainCtx;
let volumeCanvas, volumeCtx;
let macdCanvas, macdCtx;
let stochCanvas, stochCtx;
let rsiCanvas, rsiCtx;
let tooltip;

let collapsed = { volume: false, macd: false, stoch: false, rsi: false };

let indicators = {
  ma1: [], ma2: [],
  rsi: [],
  stoch: { k: [], d: [] },
  macd: { macd: [], signal: [], hist: [] }
};

let backBuffers = { main: null, volume: null, macd: null, stoch: null, rsi: null };
function resetBackBuffers(){ backBuffers.main = backBuffers.volume = backBuffers.macd = backBuffers.stoch = backBuffers.rsi = null; }
function saveBackBuffers(){
  try{
    backBuffers.main = mainCtx.getImageData(0,0,mainCanvas.width, mainCanvas.height);
    backBuffers.volume = (!collapsed.volume) ? volumeCtx.getImageData(0,0,volumeCanvas.width, volumeCanvas.height) : null;
    backBuffers.macd = (!collapsed.macd) ? macdCtx.getImageData(0,0,macdCanvas.width, macdCanvas.height) : null;
    backBuffers.stoch = (!collapsed.stoch) ? stochCtx.getImageData(0,0,stochCanvas.width, stochCanvas.height) : null;
    backBuffers.rsi = (!collapsed.rsi) ? rsiCtx.getImageData(0,0,rsiCanvas.width, rsiCanvas.height) : null;
  }catch(e){}
}
function restoreBackBuffers(){
  try{
    if(backBuffers.main) mainCtx.putImageData(backBuffers.main,0,0);
    if(!collapsed.volume && backBuffers.volume) volumeCtx.putImageData(backBuffers.volume,0,0);
    if(!collapsed.macd && backBuffers.macd) macdCtx.putImageData(backBuffers.macd,0,0);
    if(!collapsed.stoch && backBuffers.stoch) stochCtx.putImageData(backBuffers.stoch,0,0);
    if(!collapsed.rsi && backBuffers.rsi) rsiCtx.putImageData(backBuffers.rsi,0,0);
  }catch(e){}
}

let currentSymbolDisplay = "";
let rightSpaceEnabled = false;

/* =========================
   Data Version (日次キャッシュ用)
========================= */
function yyyymmddJST(){
  const now = new Date();
  const jst = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
  const y = jst.getFullYear();
  const m = String(jst.getMonth()+1).padStart(2,'0');
  const d = String(jst.getDate()).padStart(2,'0');
  return `${y}${m}${d}`;
}
const DATA_VER = yyyymmddJST();

/* =========================
   Parsing
========================= */
function toNum(s){ 
  if(s==null) return NaN; 
  return Number(String(s).replace(/,/g,'').replace(/"/g,'').trim()); 
}

function parseDelimitedLine(line, delim){
  const out=[]; let cur=""; let inQ=false;
  for(const ch of line){
    if(ch==='"'){ inQ=!inQ; continue; }
    if(ch===delim && !inQ){ out.push(cur); cur=""; }
    else cur+=ch;
  }
  out.push(cur);
  return out;
}

function detectDelimiter(headerLine){
  const tabCount=(headerLine.match(/\t/g)||[]).length;
  const commaCount=(headerLine.match(/,/g)||[]).length;
  return tabCount>=commaCount ? "\t" : ",";
}

// OHLCV形式CSV（Date,Open,High,Low,Close,Volume）をパース
function parseOHLCVFormat(text){
  const lines = text.trim().split(/\r?\n/);
  if(lines.length < 2) return [];
  
  const delim = detectDelimiter(lines[0]);
  const header = parseDelimitedLine(lines[0], delim).map(s=>s.replace(/\r/g,'').trim());
  
  // ヘッダーから各列のインデックスを取得
  const idxDate = header.findIndex(h => /date/i.test(h));
  const idxOpen = header.findIndex(h => /open/i.test(h));
  const idxHigh = header.findIndex(h => /high/i.test(h));
  const idxLow = header.findIndex(h => /low/i.test(h));
  const idxClose = header.findIndex(h => /close/i.test(h));
  const idxVolume = header.findIndex(h => /volume/i.test(h));
  
  if(idxDate < 0 || idxClose < 0) return [];
  
  const rows = [];
  for(let i = 1; i < lines.length; i++){
    const cols = parseDelimitedLine(lines[i], delim);
    if(!cols || cols.length === 0) continue;
    
    const date = (cols[idxDate] || "").trim();
    const open = idxOpen >= 0 ? toNum(cols[idxOpen]) : null;
    const high = idxHigh >= 0 ? toNum(cols[idxHigh]) : null;
    const low = idxLow >= 0 ? toNum(cols[idxLow]) : null;
    const close = toNum(cols[idxClose]);
    const volume = idxVolume >= 0 ? toNum(cols[idxVolume]) : null;
    
    if(!date || Number.isNaN(close)) continue;
    
    rows.push({
      date,
      open: Number.isNaN(open) ? close : open,
      high: Number.isNaN(high) ? close : high,
      low: Number.isNaN(low) ? close : low,
      close,
      volume: Number.isNaN(volume) ? null : volume
    });
  }
  
  return rows;
}

// chartlist.csv をパース（code,name形式、ヘッダーなし）
function parseChartList(text){
  const raw = String(text||"").replace(/\uFEFF/g,'').trim();
  if(!raw) return [];
  
  const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
  if(lines.length === 0) return [];

  const out = [];
  for(const line of lines){
    const parts = line.split(',').map(s=>s.trim());
    if(parts.length < 2) continue;
    
    const code = parts[0];
    const name = parts[1];
    if(!code) continue;
    
    out.push({ code, name });
  }
  return out;
}

/* =========================
   週足・月足データ生成
========================= */
function convertToWeekly(dailyData){
  if(!dailyData || dailyData.length === 0) return [];
  
  const weekly = [];
  let currentWeek = null;
  
  for(const day of dailyData){
    const dateObj = new Date(day.date);
    const dayOfWeek = dateObj.getDay(); // 0=日曜, 1=月曜, ..., 5=金曜
    
    // 週の開始判定（月曜日または最初のデータ）
    if(!currentWeek || dayOfWeek === 1 || dayOfWeek < currentWeek.lastDayOfWeek){
      if(currentWeek){
        weekly.push(currentWeek.data);
      }
      currentWeek = {
        data: {
          date: day.date,
          open: day.open,
          high: day.high,
          low: day.low,
          close: day.close,
          volume: day.volume || 0
        },
        lastDayOfWeek: dayOfWeek
      };
    }else{
      // 週内のデータを集約
      currentWeek.data.high = Math.max(currentWeek.data.high, day.high);
      currentWeek.data.low = Math.min(currentWeek.data.low, day.low);
      currentWeek.data.close = day.close;
      currentWeek.data.volume += (day.volume || 0);
      currentWeek.lastDayOfWeek = dayOfWeek;
    }
  }
  
  // 最後の週を追加
  if(currentWeek){
    weekly.push(currentWeek.data);
  }
  
  return weekly;
}

function convertToMonthly(dailyData){
  if(!dailyData || dailyData.length === 0) return [];
  
  const monthly = [];
  let currentMonth = null;
  
  for(const day of dailyData){
    const dateObj = new Date(day.date);
    const yearMonth = `${dateObj.getFullYear()}-${String(dateObj.getMonth() + 1).padStart(2, '0')}`;
    
    if(!currentMonth || currentMonth.yearMonth !== yearMonth){
      if(currentMonth){
        monthly.push(currentMonth.data);
      }
      currentMonth = {
        yearMonth: yearMonth,
        data: {
          date: day.date,
          open: day.open,
          high: day.high,
          low: day.low,
          close: day.close,
          volume: day.volume || 0
        }
      };
    }else{
      // 月内のデータを集約
      currentMonth.data.high = Math.max(currentMonth.data.high, day.high);
      currentMonth.data.low = Math.min(currentMonth.data.low, day.low);
      currentMonth.data.close = day.close;
      currentMonth.data.volume += (day.volume || 0);
    }
  }
  
  // 最後の月を追加
  if(currentMonth){
    monthly.push(currentMonth.data);
  }
  
  return monthly;
}

/* =========================
   CSV Loading
========================= */
async function loadSymbolCSV(code){
  if(symbolCache.has(code)) return symbolCache.get(code);
  
  try{
    const res = await fetch(`./data/${code}.csv?v=${DATA_VER}`);
    if(!res.ok) throw new Error(`fetch失敗: ${res.status}`);
    
    const text = await res.text();
    const rows = parseOHLCVFormat(text);
    
    symbolCache.set(code, rows);
    return rows;
  }catch(e){
    console.error(`${code}.csv の読み込みエラー:`, e);
    return [];
  }
}

// 前後の銘柄を先読み（非同期）
function preloadAdjacentSymbols(currentIndex){
  if(!chartListItems || chartListItems.length === 0) return;
  
  const codes = [
    chartListItems[currentIndex - 1]?.code,
    chartListItems[currentIndex + 1]?.code
  ].filter(c => c && !symbolCache.has(c));
  
  codes.forEach(code => {
    loadSymbolCSV(code).catch(() => {});
  });
}

/* =========================
   UI Population
========================= */
function populateSymbolSelect(){
  const sel = document.getElementById('symbolSelect');
  if(!sel) return;
  
  const current = sel.value;
  sel.innerHTML = "";
  
  if(!Array.isArray(chartListItems) || chartListItems.length === 0){
    const opt = document.createElement('option');
    opt.value = "";
    opt.textContent = "銘柄リストが空です";
    sel.appendChild(opt);
    return;
  }
  
  for(const item of chartListItems){
    const opt = document.createElement('option');
    opt.value = item.code;
    opt.textContent = `${item.code} ${item.name}`;
    sel.appendChild(opt);
  }
  
  if(current && chartListItems.some(item => item.code === current)){
    sel.value = current;
  }else{
    sel.selectedIndex = 0;
  }
}

async function autoLoadChartList(){
  const el = document.getElementById('autoStatus');
  try{
    el.textContent = "chartlist.csv を読み込み中...";
    const res = await fetch('./chartlist.csv');
    if(!res.ok) throw new Error(`fetch失敗: ${res.status} ${res.statusText}`);
    
    const text = await res.text();
    chartListItems = parseChartList(text);
    
    if(!Array.isArray(chartListItems) || chartListItems.length === 0){
      throw new Error("chartlist.csv が空または形式が不正です");
    }
    
    populateSymbolSelect();
    el.textContent = `読込完了: ${chartListItems.length}銘柄`;
    
    // 初回銘柄を表示
    await applySymbol();
  }catch(e){
    console.error(e);
    el.textContent = `エラー: ${e.message}`;
  }
}

/* =========================
   Technical Indicators
========================= */
function calculateMA(data, period){
  const result = new Array(data.length).fill(null);
  for(let i = period - 1; i < data.length; i++){
    let sum = 0;
    for(let j = 0; j < period; j++) sum += data[i - j].close;
    result[i] = sum / period;
  }
  return result;
}

function calculateRSI(data, period){
  const result = new Array(data.length).fill(null);
  if(data.length <= period) return result;

  let gains = 0, losses = 0;
  for(let i = 1; i <= period; i++){
    const diff = data[i].close - data[i - 1].close;
    if(diff > 0) gains += diff; 
    else losses -= diff;
  }
  let avgGain = gains / period;
  let avgLoss = losses / period;

  result[period] = (avgLoss === 0) ? 100 : (100 - (100 / (1 + avgGain / avgLoss)));

  for(let i = period + 1; i < data.length; i++){
    const diff = data[i].close - data[i - 1].close;
    const gain = diff > 0 ? diff : 0;
    const loss = diff < 0 ? -diff : 0;

    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;

    result[i] = (avgLoss === 0) ? 100 : (100 - (100 / (1 + avgGain / avgLoss)));
  }
  return result;
}

function calculateMACD(data, shortP, longP, sigP){
  const macdLine = new Array(data.length).fill(null);
  const signalLine = new Array(data.length).fill(null);
  const histogram = new Array(data.length).fill(null);

  const kS = 2 / (shortP + 1), kL = 2 / (longP + 1);

  let emaS = data[0].close;
  let emaL = data[0].close;

  for(let i = 0; i < data.length; i++){
    const price = data[i].close;
    if(i === 0){ 
      emaS = price; 
      emaL = price; 
    }else{
      emaS = (price - emaS) * kS + emaS;
      emaL = (price - emaL) * kL + emaL;
    }
    if(i >= longP - 1) macdLine[i] = emaS - emaL;
  }

  const firstValid = longP - 1;
  if(firstValid < 0 || firstValid >= data.length) 
    return { macd: macdLine, signal: signalLine, hist: histogram };

  let sigEma = macdLine[firstValid];
  const kSig = 2 / (sigP + 1);

  for(let i = firstValid; i < data.length; i++){
    if(i === firstValid){
      signalLine[i] = macdLine[i];
      sigEma = macdLine[i];
    }else{
      sigEma = (macdLine[i] - sigEma) * kSig + sigEma;
      signalLine[i] = sigEma;
    }
    histogram[i] = macdLine[i] - signalLine[i];
  }
  return { macd: macdLine, signal: signalLine, hist: histogram };
}

function calculateStochastic(data, kP, dP){
  const kLine = new Array(data.length).fill(null);
  const dLine = new Array(data.length).fill(null);

  for(let i = kP - 1; i < data.length; i++){
    let highest = -Infinity, lowest = Infinity;
    for(let j = 0; j < kP; j++){
      highest = Math.max(highest, data[i - j].high);
      lowest = Math.min(lowest, data[i - j].low);
    }
    const cur = data[i].close;
    kLine[i] = (highest !== lowest) ? (((cur - lowest) / (highest - lowest)) * 100) : 50;
  }

  for(let i = kP - 1 + dP - 1; i < data.length; i++){
    let sum = 0;
    for(let j = 0; j < dP; j++) sum += kLine[i - j];
    dLine[i] = sum / dP;
  }
  return { k: kLine, d: dLine };
}

function recomputeIndicators(){
  if(!series || series.length === 0){
    indicators.ma1 = []; 
    indicators.ma2 = [];
    indicators.rsi = [];
    indicators.stoch = { k: [], d: [] };
    indicators.macd = { macd: [], signal: [], hist: [] };
    return;
  }
  indicators.ma1 = calculateMA(series, params.ma1);
  indicators.ma2 = calculateMA(series, params.ma2);
  indicators.rsi = calculateRSI(series, params.rsi);
  indicators.stoch = calculateStochastic(series, params.stochK, params.stochD);
  indicators.macd = calculateMACD(series, params.macdShort, params.macdLong, params.macdSignal);
}

/* =========================
   Statistics Calculation
========================= */
function calcStatsForVisibleWindow(){
  if(!series || series.length === 0){
    return { winRate: null, upAvg: null, downAvg: null, bullRate: null, totalReturn: null, bullAvg: null, bearAvg: null };
  }

  const { visibleIndices } = getVisibleWindow();
  const idxs = visibleIndices.filter(i => i != null);
  if(idxs.length === 0){
    return { winRate: null, upAvg: null, downAvg: null, bullRate: null, totalReturn: null, bullAvg: null, bearAvg: null };
  }

  // 陽線率: close > open
  let bullN = 0, bullDen = 0;
  
  // 陽線時平均・陰線時平均（始値→終値の変化率）
  let bullSum = 0, bullCnt = 0;
  let bearSum = 0, bearCnt = 0;

  // 前日比（窓内比較）：勝率・上昇時平均・下落時平均
  let winN = 0, winDen = 0;
  let upSum = 0, upCnt = 0;
  let downSum = 0, downCnt = 0;

  // 騰落率：表示範囲の最初の始値から最後の終値まで
  let firstOpen = null, lastClose = null;
  for(let k = 0; k < idxs.length; k++){
    const i = idxs[k];
    const c = series[i];
    if(!c) continue;

    if(firstOpen === null && c.open != null){
      firstOpen = c.open;
    }
    if(c.close != null){
      lastClose = c.close;
    }

    // bull rate: close > open
    if(c.open != null && c.close != null && c.open !== 0){
      bullDen++;
      const ocPct = ((c.close - c.open) / c.open) * 100;
      
      if(c.close > c.open){
        bullN++;
        bullSum += ocPct;
        bullCnt++;
      }else if(c.close < c.open){
        bearSum += ocPct;
        bearCnt++;
      }
    }

    // prev-close compare within visible window (k>=1)
    if(k >= 1){
      const ip = idxs[k - 1];
      const p = series[ip];
      if(p && p.close != null && c.close != null && p.close !== 0){
        const retPct = ((c.close - p.close) / p.close) * 100;

        winDen++;
        if(retPct > 0) winN++;

        if(retPct > 0){
          upSum += retPct; 
          upCnt++;
        }else if(retPct < 0){
          downSum += retPct; 
          downCnt++;
        }
      }
    }
  }

  const bullRate = bullDen > 0 ? (bullN / bullDen) * 100 : null;
  const winRate = winDen > 0 ? (winN / winDen) * 100 : null;
  const upAvg = upCnt > 0 ? (upSum / upCnt) : null;
  const downAvg = downCnt > 0 ? (downSum / downCnt) : null;
  const bullAvg = bullCnt > 0 ? (bullSum / bullCnt) : null;
  const bearAvg = bearCnt > 0 ? (bearSum / bearCnt) : null;
  const totalReturn = (firstOpen != null && lastClose != null && firstOpen !== 0) 
    ? ((lastClose - firstOpen) / firstOpen) * 100 
    : null;

  return { winRate, upAvg, downAvg, bullRate, totalReturn, bullAvg, bearAvg };
}

/* =========================
   View Management
========================= */
function clampView(){
  if(!series || series.length === 0){
    displayCount = Math.max(10, displayCount);
    offsetX = 0;
    return;
  }
  const minCount = 10;
  const maxCount = Math.max(minCount, series.length);
  displayCount = Math.max(minCount, Math.min(displayCount, maxCount));

  const maxOffset = Math.max(0, series.length - displayCount);
  offsetX = Math.max(0, Math.min(Math.round(offsetX), maxOffset));
}

function getVisibleWindow(){
  clampView();
  const n = series.length;

  const extraSpace = rightSpaceEnabled ? 5 : 0;

  const startRaw = n - displayCount - offsetX;
  const endRaw = startRaw + displayCount;

  const start = Math.max(0, startRaw);
  const end = Math.min(n, endRaw);

  const realSlice = (start < end) ? series.slice(start, end) : [];
  const realLen = realSlice.length;

  const leftPadN = displayCount - realLen;
  const leftPads = new Array(leftPadN).fill(null).map(() => ({ 
    date: "", open: null, high: null, low: null, close: null, volume: null 
  }));

  const rightPads = new Array(extraSpace).fill(null).map(() => ({ 
    date: "", open: null, high: null, low: null, close: null, volume: null 
  }));

  const visibleCandles = leftPads.concat(realSlice, rightPads);

  const visibleIndices = new Array(leftPadN).fill(null).concat(
    Array.from({ length: realLen }, (_, i) => start + i),
    new Array(extraSpace).fill(null)
  );

  return { visibleCandles, visibleIndices, startSeriesIndex: start, endSeriesIndex: end };
}

function updateViewInfo(){
  const el = document.getElementById('viewInfo');
  if(!series || series.length === 0){
    el.textContent = `表示本数: ${displayCount} / 表示範囲: -`;
    return;
  }
  const { visibleCandles } = getVisibleWindow();

  let startDate = null, endDate = null;
  for(let i = 0; i < visibleCandles.length; i++){ 
    if(visibleCandles[i].date){ 
      startDate = visibleCandles[i].date; 
      break; 
    } 
  }
  for(let i = visibleCandles.length - 1; i >= 0; i--){ 
    if(visibleCandles[i].date){ 
      endDate = visibleCandles[i].date; 
      break; 
    } 
  }

  const timeframeLabel = timeframe === 'daily' ? '日足' : timeframe === 'weekly' ? '週足' : '月足';
  el.textContent = `${timeframeLabel} 表示本数: ${displayCount} / 表示範囲: ${startDate && endDate ? `${startDate} ~ ${endDate}` : '-'}`;
}

/* =========================
   Symbol Application
========================= */
async function applySymbol(){
  const sel = document.getElementById('symbolSelect');
  const code = sel?.value;
  
  if(!code) return;
  
  const selectedOption = sel?.selectedOptions?.[0];
  currentSymbolDisplay = selectedOption?.textContent || code;
  
  // CSVを読み込み（日足データ）
  dailySeries = await loadSymbolCSV(code);
  
  // 時間軸に応じてseriesを設定
  updateTimeframeSeries();
  
  offsetX = 0;

  const q = document.getElementById('quickSelect')?.value;
  if(q) displayCount = parseInt(q, 10);

  recomputeIndicators();

  document.getElementById('status').textContent = 
    (series.length > 0)
      ? `${currentSymbolDisplay}: ${series.length}件`
      : `${currentSymbolDisplay}: データなし`;

  updateViewInfo();
  drawChart();
  
  // 前後の銘柄を先読み
  preloadAdjacentSymbols(sel.selectedIndex);
}

function updateTimeframeSeries(){
  if(timeframe === 'daily'){
    series = dailySeries;
  }else if(timeframe === 'weekly'){
    series = convertToWeekly(dailySeries);
  }else if(timeframe === 'monthly'){
    series = convertToMonthly(dailySeries);
  }
}

function switchTimeframe(newTimeframe){
  if(timeframe === newTimeframe) return;
  
  timeframe = newTimeframe;
  updateTimeframeSeries();
  
  // 表示位置をリセット
  offsetX = 0;
  
  recomputeIndicators();
  updateViewInfo();
  drawChart();
}

/* =========================
   Drawing
========================= */
function drawChart(){
  if(!mainCanvas) return;

  if(!series || series.length === 0){
    resetBackBuffers();
    mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    mainCtx.fillStyle = '#666';
    mainCtx.textAlign = 'center';
    mainCtx.fillText("No Data", mainCanvas.width / 2, mainCanvas.height / 2);
    return;
  }

  const { visibleCandles, visibleIndices } = getVisibleWindow();

  drawMain(visibleCandles, visibleIndices);
  drawVolume(visibleCandles, visibleIndices);
  drawMacd(visibleIndices);
  drawStoch(visibleIndices);
  drawRsi(visibleIndices);

  saveBackBuffers();
}

function drawMain(visibleCandles, visibleIndices){
  const ctx = mainCtx;
  const w = mainCanvas.width, h = mainCanvas.height;
  const pad = { t: 20, b: 30, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;

  ctx.clearRect(0, 0, w, h);

  // 銘柄名と統計情報を背景として表示
  if(currentSymbolDisplay){
    const { winRate, upAvg, downAvg, bullRate, totalReturn, bullAvg, bearAvg } = calcStatsForVisibleWindow();
    
    const fmtPct = (v) => (v == null || Number.isNaN(v)) ? "-" : v.toFixed(1) + "%";
    const fmtAvg = (v) => {
      if(v == null || Number.isNaN(v)) return "-";
      const sign = v >= 0 ? "+" : "";
      return sign + v.toFixed(1) + "%";
    };

    const timeframeLabel = timeframe === 'daily' ? '' : timeframe === 'weekly' ? '（週足）' : '（月足）';

    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    // 1行目：銘柄名（大きいフォント、薄いグレー）+ 騰落率（普通フォント、濃いグレー）
    ctx.fillStyle = '#acacac';
    ctx.font = 'bold 36px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.fillText(currentSymbolDisplay + timeframeLabel, pad.l + 5, pad.t + 5);
    
    // 銘柄名の幅を測定して、その右に騰落率を配置
    const nameWidth = ctx.measureText(currentSymbolDisplay + timeframeLabel).width;
    ctx.fillStyle = '#acacac';
    ctx.font = '18px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
    ctx.fillText(`騰落率${fmtAvg(totalReturn)}`, pad.l + 5 + nameWidth + 10, pad.t + 20);
    
    // 2行目：勝率と平均（小さいフォント、濃いグレー）
    const line2 = `勝率${fmtPct(winRate)}（上昇時平均${fmtAvg(upAvg)}、下落時平均${fmtAvg(downAvg)}）`;
    ctx.fillText(line2, pad.l + 5, pad.t + 45);
    
    // 3行目：陽線率と陽線時平均・陰線時平均
    const line3 = `陽線率${fmtPct(bullRate)}（陽線時平均${fmtAvg(bullAvg)}、陰線時平均${fmtAvg(bearAvg)}）`;
    ctx.fillText(line3, pad.l + 5, pad.t + 65);
    
    ctx.restore();
  }

  let minP = Infinity, maxP = -Infinity;

  visibleIndices.forEach((sIdx, i) => {
    const c = visibleCandles[i];

    if(c.high != null) maxP = Math.max(maxP, c.high);
    if(c.low != null) minP = Math.min(minP, c.low);
    if(c.open != null){ minP = Math.min(minP, c.open); maxP = Math.max(maxP, c.open); }
    if(c.close != null){ minP = Math.min(minP, c.close); maxP = Math.max(maxP, c.close); }

    if(sIdx != null){
      const m1 = indicators.ma1[sIdx];
      const m2 = indicators.ma2[sIdx];
      if(m1 != null){ minP = Math.min(minP, m1); maxP = Math.max(maxP, m1); }
      if(m2 != null){ minP = Math.min(minP, m2); maxP = Math.max(maxP, m2); }
    }
  });

  if(minP === Infinity){
    ctx.fillStyle = '#666'; 
    ctx.textAlign = 'center'; 
    ctx.fillText("No Data", w / 2, h / 2);
    return;
  }

  const range = (maxP - minP) || 1;
  minP -= range * 0.05; 
  maxP += range * 0.05;
  const scaleY = chartH / (maxP - minP);

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleCandles.length);
  const getY = (val) => pad.t + chartH - (val - minP) * scaleY;

  const roundPrice = (price) => {
    if(price < 1000) return Math.round(price / 10) * 10;
    if(price < 3000) return Math.round(price / 50) * 50;
    if(price < 5000) return Math.round(price / 100) * 100;
    return Math.round(price / 500) * 500;
  };

  ctx.strokeStyle = '#eee'; 
  ctx.lineWidth = 1;
  const gridSteps = 5;
  for(let i = 0; i <= gridSteps; i++){
    const y = pad.t + (chartH * i / gridSteps);
    const rawPrice = maxP - (maxP - minP) * (i / gridSteps);
    const price = roundPrice(rawPrice);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
    ctx.fillStyle = '#666'; 
    ctx.textAlign = 'left';
    ctx.fillText(price.toLocaleString(), w - pad.r + 5, y + 4);
  }

  mainCanvas.candlePositions = visibleCandles.map((c, i) => ({
    x: getX(i),
    w: chartW / visibleCandles.length,
    vIndex: i,
    seriesIndex: visibleIndices[i]
  }));

  visibleCandles.forEach((c, i) => {
    if(c.date && i % Math.ceil(visibleCandles.length / 6) === 0){
      ctx.fillStyle = '#999';
      ctx.textAlign = 'center';
      ctx.fillText(c.date, getX(i), h - 5);
    }
  });

  // ローソク足描画
  const bodyW = (chartW / visibleCandles.length) * 0.6;
  ctx.lineWidth = 1;

  visibleCandles.forEach((c, i) => {
    if(c.open == null || c.high == null || c.low == null || c.close == null) return;

    const x = getX(i);
    const yH = getY(c.high);
    const yL = getY(c.low);
    const yO = getY(c.open);
    const yC = getY(c.close);

    const up = c.close >= c.open;
    const col = up ? '#26a69a' : '#ef5350';

    ctx.strokeStyle = col;
    ctx.beginPath();
    ctx.moveTo(x, yH);
    ctx.lineTo(x, yL);
    ctx.stroke();

    const top = Math.min(yO, yC);
    const bot = Math.max(yO, yC);
    const height = Math.max(1, bot - top);

    ctx.fillStyle = col;
    ctx.fillRect(x - bodyW / 2, top, bodyW, height);

    ctx.strokeStyle = col;
    ctx.strokeRect(x - bodyW / 2, top, bodyW, height);
  });

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else{
        m = false;
      }
    });
    ctx.stroke();
  };
  drawLine(indicators.ma1, '#ff9800');
  drawLine(indicators.ma2, '#2196f3');
}

function drawVolume(visibleCandles, visibleIndices){
  if(collapsed.volume) return;
  const ctx = volumeCtx;
  const w = volumeCanvas.width, h = volumeCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  let maxVol = 0;
  visibleCandles.forEach(c => {
    if(c.volume != null && c.volume > maxVol) maxVol = c.volume;
  });

  if(maxVol === 0) maxVol = 1;
  const scaleY = chartH / maxVol;

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleCandles.length);
  const getY = (vol) => pad.t + chartH - (vol * scaleY);

  const barW = (chartW / visibleCandles.length) * 0.7;

  visibleCandles.forEach((c, i) => {
    if(c.volume == null || c.volume === 0) return;
    
    const x = getX(i);
    const y = getY(c.volume);
    const y0 = pad.t + chartH;

    let color = '#999';
    if(c.open != null && c.close != null){
      color = c.close >= c.open ? '#26a69a' : '#ef5350';
    }

    ctx.fillStyle = color;
    ctx.fillRect(x - barW / 2, y, barW, y0 - y);
  });

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`出来高`, 5, 10);
}

function drawMacd(visibleIndices){
  if(collapsed.macd) return;
  const ctx = macdCtx;
  const w = macdCanvas.width, h = macdCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.macd;
  let minV = Infinity, maxV = -Infinity;

  visibleIndices.forEach(sIdx => {
    if(sIdx == null) return;
    const m = data.macd[sIdx], s = data.signal[sIdx], hi = data.hist[sIdx];
    if(m != null){ minV = Math.min(minV, m); maxV = Math.max(maxV, m); }
    if(s != null){ minV = Math.min(minV, s); maxV = Math.max(maxV, s); }
    if(hi != null){ minV = Math.min(minV, hi); maxV = Math.max(maxV, hi); }
  });

  if(minV === Infinity){ minV = -1; maxV = 1; }
  const range = Math.max(0.0001, maxV - minV);
  const scaleY = chartH / range;

  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v - minV) * scaleY;

  const y0 = getY(0);
  ctx.strokeStyle = '#ccc'; 
  ctx.beginPath(); 
  ctx.moveTo(pad.l, y0); 
  ctx.lineTo(w - pad.r, y0); 
  ctx.stroke();

  const barW = (chartW / visibleIndices.length) * 0.7;
  visibleIndices.forEach((sIdx, i) => {
    if(sIdx == null) return;
    const v = data.hist[sIdx];
    if(v != null){
      const x = getX(i), y = getY(v);
      ctx.fillStyle = v >= 0 ? '#26a69a' : '#ef5350';
      ctx.fillRect(x - barW / 2, Math.min(y, y0), barW, Math.abs(y - y0));
    }
  });

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else m = false;
    });
    ctx.stroke();
  };
  drawLine(data.macd, '#2196f3');
  drawLine(data.signal, '#ff9800');

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`MACD(${params.macdShort},${params.macdLong},${params.macdSignal})`, 5, 10);
}

function drawStoch(visibleIndices){
  if(collapsed.stoch) return;
  const ctx = stochCtx;
  const w = stochCanvas.width, h = stochCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.stoch;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.strokeStyle = '#eee'; 
  ctx.setLineDash([4, 4]);
  [20, 80].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
  });
  ctx.setLineDash([]);

  const drawLine = (arr, color) => {
    ctx.strokeStyle = color; 
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let m = false;
    visibleIndices.forEach((sIdx, i) => {
      if(sIdx == null){ m = false; return; }
      const v = arr[sIdx];
      if(v != null){
        const x = getX(i), y = getY(v);
        if(!m){ ctx.moveTo(x, y); m = true; } 
        else ctx.lineTo(x, y);
      }else m = false;
    });
    ctx.stroke();
  };
  drawLine(data.k, '#00bcd4');
  drawLine(data.d, '#ff5722');

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`Stoch(${params.stochK},${params.stochD})`, 5, 10);
}

function drawRsi(visibleIndices){
  if(collapsed.rsi) return;
  const ctx = rsiCtx;
  const w = rsiCanvas.width, h = rsiCanvas.height;
  const pad = { t: 10, b: 10, l: 10, r: 60 };
  const chartW = w - pad.l - pad.r;
  const chartH = h - pad.t - pad.b;
  ctx.clearRect(0, 0, w, h);

  const data = indicators.rsi;
  const getX = (i) => pad.l + (i + 0.5) * (chartW / visibleIndices.length);
  const getY = (v) => pad.t + chartH - (v / 100) * chartH;

  ctx.fillStyle = 'rgba(156, 39, 176, 0.05)';
  const y70 = getY(70), y30 = getY(30);
  ctx.fillRect(pad.l, y70, chartW, y30 - y70);

  ctx.strokeStyle = '#ccc'; 
  ctx.setLineDash([4, 4]);
  [30, 70].forEach(level => {
    const y = getY(level);
    ctx.beginPath(); 
    ctx.moveTo(pad.l, y); 
    ctx.lineTo(w - pad.r, y); 
    ctx.stroke();
  });
  ctx.setLineDash([]);

  ctx.strokeStyle = '#9c27b0'; 
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  let m = false;
  visibleIndices.forEach((sIdx, i) => {
    if(sIdx == null){ m = false; return; }
    const v = data[sIdx];
    if(v != null){
      const x = getX(i), y = getY(v);
      if(!m){ ctx.moveTo(x, y); m = true; } 
      else ctx.lineTo(x, y);
    }else m = false;
  });
  ctx.stroke();

  ctx.fillStyle = '#666'; 
  ctx.textAlign = 'left';
  ctx.fillText(`RSI(${params.rsi})`, 5, 10);
}

function drawCrosshair(x){
  restoreBackBuffers();
  if(x < 0) return;
  const draw = (ctx, h) => {
    if(!ctx) return;
    ctx.save();
    ctx.strokeStyle = '#999';
    ctx.setLineDash([3, 3]);
    ctx.beginPath(); 
    ctx.moveTo(x, 0); 
    ctx.lineTo(x, h); 
    ctx.stroke();
    ctx.restore();
  };
  draw(mainCtx, mainCanvas.height);
  if(!collapsed.volume) draw(volumeCtx, volumeCanvas.height);
  if(!collapsed.macd) draw(macdCtx, macdCanvas.height);
  if(!collapsed.stoch) draw(stochCtx, stochCanvas.height);
  if(!collapsed.rsi) draw(rsiCtx, rsiCanvas.height);
}

function handleTooltip(e, canvas){
  if(!mainCanvas.candlePositions || !series || series.length === 0) return;

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;

  const p = mainCanvas.candlePositions.find(pp => 
    mouseX >= pp.x - pp.w / 2 && mouseX <= pp.x + pp.w / 2
  );
  if(!p){
    tooltip.style.display = 'none';
    drawCrosshair(-1);
    return;
  }

  const sIdx = p.seriesIndex;
  if(sIdx == null){
    tooltip.style.display = 'none';
    drawCrosshair(p.x);
    return;
  }

  const c = series[sIdx];
  const fmt = n => (n !== null && n !== undefined && !Number.isNaN(n))
    ? n.toLocaleString(undefined, { maximumFractionDigits: 2 })
    : '-';

  const ma1 = indicators.ma1[sIdx], ma2 = indicators.ma2[sIdx];
  const rsi = indicators.rsi[sIdx];
  const stK = indicators.stoch.k[sIdx], stD = indicators.stoch.d[sIdx];
  const macd = indicators.macd.macd[sIdx], sig = indicators.macd.signal[sIdx];

  const timeframeLabel = timeframe === 'daily' ? '' : timeframe === 'weekly' ? '（週足）' : '（月足）';

  let html = `<strong>${c.date}${timeframeLabel}</strong><br>`;
  html += `始:${fmt(c.open)} 高:${fmt(c.high)} 安:${fmt(c.low)} 終:${fmt(c.close)}<br>`;
  if(c.volume != null){
    html += `出来高:${fmt(c.volume)}<br>`;
  }
  html += `<span style="color:#ff9800">MA${params.ma1}:${fmt(ma1)}</span> <span style="color:#2196f3">MA${params.ma2}:${fmt(ma2)}</span><br>`;
  html += `<span style="color:#9c27b0">RSI:${fmt(rsi)}</span><br>`;
  html += `<span style="color:#00bcd4">K:${fmt(stK)}</span> <span style="color:#ff5722">D:${fmt(stD)}</span><br>`;
  html += `MACD:${fmt(macd)} Sig:${fmt(sig)}`;

  tooltip.innerHTML = html;
  tooltip.style.display = 'block';

  let tx = e.clientX + 15, ty = e.clientY + 15;
  if(tx + 150 > window.innerWidth) tx -= 160;
  tooltip.style.left = tx + 'px';
  tooltip.style.top = ty + 'px';

  drawCrosshair(p.x);
}

/* =========================
   Interaction
========================= */
function onWheelZoom(e){
  e.preventDefault();
  if(!series || series.length === 0) return;

  const shrink = (e.deltaY < 0);

  displayCount += (shrink ? -1 : +1);

  clampView();
  updateViewInfo();

  const qs = document.getElementById('quickSelect');
  if(qs) qs.value = "";

  drawChart();
}

function onMouseDown(e, cvs){
  if(!series || series.length === 0) return;
  isDragging = true;
  dragStartX = e.clientX;
  dragStartOffset = offsetX;
  document.body.style.cursor = 'grabbing';
}

function onMouseMove(e, cvs){
  if(!series || series.length === 0) return;

  if(isDragging){
    const rect = cvs.getBoundingClientRect();
    const w = rect.width - 100;
    const diffX = e.clientX - dragStartX;
    const ppc = Math.max(1, w / displayCount);
    const candleMove = diffX / ppc;

    let newOffset = dragStartOffset + candleMove;
    const maxOffset = Math.max(0, series.length - displayCount);
    newOffset = Math.max(0, Math.min(newOffset, maxOffset));
    offsetX = newOffset;

    updateViewInfo();
    drawChart();
  }else{
    handleTooltip(e, cvs);
  }
}

function onMouseUp(){
  isDragging = false;
  document.body.style.cursor = 'default';
}

function onMouseLeave(){
  if(isDragging) onMouseUp();
  tooltip.style.display = 'none';
  drawCrosshair(-1);
}

function toggleIndicator(key){
  collapsed[key] = !collapsed[key];
  const wrapper = document.getElementById(key + 'Wrapper');
  const collapseBtn = document.getElementById(key + 'CollapseBtn');
  const expandBtn = document.getElementById(key + 'ExpandBtn');
  
  if(collapsed[key]){
    wrapper.classList.add('collapsed');
    collapseBtn.style.display = 'none';
    expandBtn.style.display = 'flex';
  }else{
    wrapper.classList.remove('collapsed');
    collapseBtn.style.display = 'flex';
    expandBtn.style.display = 'none';
  }
  setTimeout(resizeCanvas, 210);
}

function moveIndicator(key, dir){
  const container = document.getElementById(key + 'Container');
  const parent = document.getElementById('indicatorsList');
  if(dir === 'up'){
    const prev = container.previousElementSibling;
    if(prev) parent.insertBefore(container, prev);
  }else{
    const next = container.nextElementSibling;
    if(next) parent.insertBefore(next, container);
  }
  setTimeout(resizeCanvas, 0);
}

function resizeCanvas(){
  resetBackBuffers();
  const resize = (c) => {
    if(!c) return;
    const rect = c.getBoundingClientRect();
    c.width = rect.width; 
    c.height = rect.height;
  };
  resize(mainCanvas); 
  resize(volumeCanvas); 
  resize(macdCanvas); 
  resize(stochCanvas); 
  resize(rsiCanvas);
  drawChart();
}

/* =========================
   Event Setup
========================= */
function setupEventListeners(){
  const helpBtn = document.getElementById('helpBtn');
  const helpModal = document.getElementById('helpModal');
  const helpCloseBtn = document.getElementById('helpCloseBtn');
  const openHelp = () => { 
    helpModal.style.display = 'flex'; 
    helpModal.setAttribute('aria-hidden', 'false'); 
  };
  const closeHelp = () => { 
    helpModal.style.display = 'none'; 
    helpModal.setAttribute('aria-hidden', 'true'); 
  };
  helpBtn.addEventListener('click', openHelp);
  helpCloseBtn.addEventListener('click', closeHelp);
  helpModal.addEventListener('click', (e) => { 
    if(e.target === helpModal) closeHelp(); 
  });
  window.addEventListener('keydown', (e) => { 
    if(e.key === 'Escape' && helpModal.style.display === 'flex') closeHelp(); 
  });

  document.getElementById('symbolSelect')?.addEventListener('change', () => applySymbol());

  document.getElementById('symbolSelect')?.addEventListener('keydown', (e) => {
    const sel = e.target;
    const currentIndex = sel.selectedIndex;
    const maxIndex = sel.options.length - 1;
    let newIndex = currentIndex;

    if(e.key === 'ArrowRight'){
      e.preventDefault();
      newIndex = Math.min(currentIndex + 1, maxIndex);
    }else if(e.key === 'ArrowLeft'){
      e.preventDefault();
      newIndex = Math.max(currentIndex - 1, 0);
    }else if(e.key === 'ArrowDown'){
      e.preventDefault();
      newIndex = Math.min(currentIndex + 10, maxIndex);
    }else if(e.key === 'ArrowUp'){
      e.preventDefault();
      newIndex = Math.max(currentIndex - 10, 0);
    }

    if(newIndex !== currentIndex){
      sel.selectedIndex = newIndex;
      applySymbol();
    }
  });

  document.getElementById('quickSelect')?.addEventListener('change', (e) => {
    const v = e.target.value;
    if(!v) return;
    displayCount = parseInt(v, 10);
    offsetX = 0;
    clampView();
    updateViewInfo();
    drawChart();
  });

  document.getElementById('rightSpaceCheck')?.addEventListener('change', (e) => {
    rightSpaceEnabled = e.target.checked;
    drawChart();
  });

  // 時間軸切替のチェックボックス
  const dailyCheck = document.getElementById('dailyCheck');
  const weeklyCheck = document.getElementById('weeklyCheck');
  const monthlyCheck = document.getElementById('monthlyCheck');

  dailyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      weeklyCheck.checked = false;
      monthlyCheck.checked = false;
      switchTimeframe('daily');
    }else{
      e.target.checked = true; // 最低1つは選択
    }
  });

  weeklyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      dailyCheck.checked = false;
      monthlyCheck.checked = false;
      switchTimeframe('weekly');
    }else{
      e.target.checked = true; // 最低1つは選択
    }
  });

  monthlyCheck?.addEventListener('change', (e) => {
    if(e.target.checked){
      dailyCheck.checked = false;
      weeklyCheck.checked = false;
      switchTimeframe('monthly');
    }else{
      e.target.checked = true; // 最低1つは選択
    }
  });

  const inputs = document.querySelectorAll('.param-group input');
  inputs.forEach(inp => {
    inp.addEventListener('change', e => {
      const id = e.target.id;
      const val = parseInt(e.target.value, 10);
      if(!(val > 0)) return;

      if(id === 'ma1Period') params.ma1 = val;
      if(id === 'ma2Period') params.ma2 = val;
      if(id === 'rsiPeriod') params.rsi = val;
      if(id === 'stochK') params.stochK = val;
      if(id === 'stochD') params.stochD = val;
      if(id === 'macdShort') params.macdShort = val;
      if(id === 'macdLong') params.macdLong = val;
      if(id === 'macdSignal') params.macdSignal = val;

      recomputeIndicators();
      drawChart();
    });
  });

  const canvases = [mainCanvas, volumeCanvas, macdCanvas, stochCanvas, rsiCanvas];
  canvases.forEach(cvs => {
    if(!cvs) return;

    cvs.addEventListener('wheel', onWheelZoom, { passive: false });

    cvs.addEventListener('mousedown', (e) => onMouseDown(e, cvs));
    cvs.addEventListener('mousemove', (e) => onMouseMove(e, cvs));
    cvs.addEventListener('mouseup', onMouseUp);
    cvs.addEventListener('mouseleave', onMouseLeave);
  });

  window.addEventListener('resize', resizeCanvas);
}

/* =========================
   Init
========================= */
function init(){
  mainCanvas = document.getElementById('mainChart');
  mainCtx = mainCanvas.getContext('2d');

  volumeCanvas = document.getElementById('volumeChart');
  volumeCtx = volumeCanvas.getContext('2d');

  macdCanvas = document.getElementById('macdChart');
  macdCtx = macdCanvas.getContext('2d');

  stochCanvas = document.getElementById('stochChart');
  stochCtx = stochCanvas.getContext('2d');

  rsiCanvas = document.getElementById('rsiChart');
  rsiCtx = rsiCanvas.getContext('2d');

  tooltip = document.getElementById('tooltip');

  setupEventListeners();
  resizeCanvas();
  autoLoadChartList();
}

window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
